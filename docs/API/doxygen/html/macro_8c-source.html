<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>libSPF v1.0: macro.c Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.8 -->
<div class="qindex">  <form class="search" action="search.php" method="get">
<a class="qindex" href="main.html">Main&nbsp;Page</a> | <a class="qindex" href="annotated.html">Data&nbsp;Structures</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Data&nbsp;Fields</a> | <a class="qindex" href="globals.html">Globals</a>  | <span class="search"><u>S</u>earch&nbsp;for&nbsp;<input class="search" type="text" name="query" value="" size="20" accesskey="s"/></span></form></div>
<h1>macro.c</h1><a href="macro_8c.html">Go to the documentation of this file.</a><pre class="fragment"><div>00001 <span class="comment">/* libspf - Sender Policy Framework library</span>
00002 <span class="comment">*</span>
00003 <span class="comment">*  ANSI C implementation of spf-draft-200405.txt</span>
00004 <span class="comment">*</span>
00005 <span class="comment">*  Author: James Couzens &lt;jcouzens@codeshare.ca&gt;</span>
00006 <span class="comment">*  Author: Sean Comeau   &lt;scomeau@obscurity.org&gt;</span>
00007 <span class="comment">*</span>
00008 <span class="comment">*  File:   util.c</span>
00009 <span class="comment">*  Desc:   Utility functions</span>
00010 <span class="comment">*</span>
00011 <span class="comment">*  License:</span>
00012 <span class="comment">*</span>
00013 <span class="comment">*  The libspf Software License, Version 1.0</span>
00014 <span class="comment">*</span>
00015 <span class="comment">*  Copyright (c) 2004 James Couzens &amp; Sean Comeau  All rights</span>
00016 <span class="comment">*  reserved.</span>
00017 <span class="comment">*</span>
00018 <span class="comment">*  Redistribution and use in source and binary forms, with or without</span>
00019 <span class="comment">*  modification, are permitted provided that the following conditions</span>
00020 <span class="comment">*  are met:</span>
00021 <span class="comment">*</span>
00022 <span class="comment">*  1. Redistributions of source code must retain the above copyright</span>
00023 <span class="comment">*     notice, this list of conditions and the following disclaimer.</span>
00024 <span class="comment">*</span>
00025 <span class="comment">*  2. Redistributions in binary form must reproduce the above copyright</span>
00026 <span class="comment">*     notice, this list of conditions and the following disclaimer in</span>
00027 <span class="comment">*     the documentation and/or other materials provided with the</span>
00028 <span class="comment">*     distribution.</span>
00029 <span class="comment">*</span>
00030 <span class="comment">*  THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED</span>
00031 <span class="comment">*  WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES</span>
00032 <span class="comment">*  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE</span>
00033 <span class="comment">*  DISCLAIMED.  IN NO EVENT SHALL THE AUTHORS MAKING USE OF THIS LICESEN</span>
00034 <span class="comment">*  OR ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,</span>
00035 <span class="comment">*  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT</span>
00036 <span class="comment">*  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF</span>
00037 <span class="comment">*  USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND</span>
00038 <span class="comment">*  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,</span>
00039 <span class="comment">*  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT</span>
00040 <span class="comment">*  OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF</span>
00041 <span class="comment">*  SUCH DAMAGE.</span>
00042 <span class="comment">*</span>
00043 <span class="comment">*/</span>
00044 
00045 <span class="preprocessor">#include "<a class="code" href="spf_8h.html">spf.h</a>"</span>
00046 <span class="preprocessor">#include "<a class="code" href="dns_8h.html">dns.h</a>"</span>
00047 <span class="preprocessor">#include "<a class="code" href="macro_8h.html">macro.h</a>"</span>
00048 <span class="preprocessor">#include "<a class="code" href="util_8h.html">util.h</a>"</span>
00049 
00050 
00051 <span class="comment">/* MACRO_expand</span>
00052 <span class="comment">*</span>
00053 <span class="comment">*  Author: Sean Comeau &lt;scomeau@obscurity.org&gt;</span>
00054 <span class="comment">*  Author: James Couzens &lt;jcouzens@codeshare.ca&gt;</span>
00055 <span class="comment">*</span>
00056 <span class="comment">*  Date:    01/18/04</span>
00057 <span class="comment">*  Updated: 06/29/04 Roger Moser &lt;Roger.Moser@pamho.net&gt;</span>
00058 <span class="comment">*</span>
00059 <span class="comment">*  Desc:</span>
00060 <span class="comment">*        Walks a string of macros tokenizing and expanding them along the</span>
00061 <span class="comment">*  way, each token being inserted as a node into a linked list.  Once the</span>
00062 <span class="comment">*  walk is complete the list is walked and the nodes are copied back out</span>
00063 <span class="comment">*  in the order they were added as expanded macros into a string which is</span>
00064 <span class="comment">*  then passed back to the calling function.</span>
00065 <span class="comment">*</span>
00066 <span class="comment">*  MACRO_freebuf is removed and I moved the code inside of this function since</span>
00067 <span class="comment">*  before calling it, it was being walked anyway to copy out each string into</span>
00068 <span class="comment">*  the return buffer, so now it just free's directly after and then destructs.</span>
00069 <span class="comment">*</span>
00070 <span class="comment">*/</span>
<a name="l00071"></a><a class="code" href="macro_8h.html#a1">00071</a> <span class="keywordtype">char</span> *<a class="code" href="macro_8h.html#a1">MACRO_expand</a>(<a class="code" href="structpeer__info__s.html">peer_info_t</a> *p, <span class="keyword">const</span> <span class="keywordtype">char</span> *s)
00072 {
00073   <span class="keyword">const</span> <span class="keywordtype">char</span> * <span class="keyword">const</span> macro_p = <span class="stringliteral">"%"</span>;     <span class="comment">/* % (literal) */</span>
00074   <span class="keyword">const</span> <span class="keywordtype">char</span> * <span class="keyword">const</span> macro_d = <span class="stringliteral">"%20"</span>;   <span class="comment">/* "URL" space */</span>
00075   <span class="keyword">const</span> <span class="keywordtype">char</span> * <span class="keyword">const</span> macro_u = <span class="stringliteral">" "</span>;     <span class="comment">/* whitespace */</span>
00076 
00077   <span class="keywordtype">char</span> *buf;                            <span class="comment">/* return buffer */</span>
00078   <span class="keywordtype">char</span> *ptr;                            <span class="comment">/* working pointer */</span>
00079   <span class="keywordtype">char</span> *cp;                             <span class="comment">/* working pointer */</span>
00080   <span class="keywordtype">char</span> *macro;
00081   <span class="keywordtype">char</span> *s_macro;                        <span class="comment">/* single char macro */</span>
00082 
00083   <a class="code" href="structstrbuf__s.html">strbuf_t</a> *master;                     <span class="comment">/* list pointers */</span>
00084   <a class="code" href="structstrbuf__node__s.html">strbuf_node_t</a> *c_node;                <span class="comment">/* c_node node */</span>
00085   <a class="code" href="structstrbuf__node__s.html">strbuf_node_t</a> *kill_node;             <span class="comment">/* temp node used in destruct */</span>
00086 
00087   size_t len;                           <span class="comment">/* leng of passed string */</span>
00088   size_t i = 0;                         <span class="comment">/* index on a str */</span>
00089   size_t length = 0;                    <span class="comment">/* overall len of expanded str */</span>
00090 
00091 
00092   <span class="keywordflow">if</span> (s == NULL)
00093   {
00094     <a class="code" href="util_8h.html#a13">xepprintf</a>(<span class="stringliteral">"Passed a NULL string.  Abort!\n"</span>);
00095     <span class="keywordflow">return</span>(NULL);
00096   }
00097 
00098   len = strlen(s);
00099   ptr = cp = <a class="code" href="util_8h.html#a8">xstrndup</a>(s, (len + 1));
00100 
00101   master = <a class="code" href="util_8h.html#a4">xmalloc</a>(<a class="code" href="util_8h.html#a3">SIZEOF</a>(<a class="code" href="structstrbuf__s.html">strbuf_t</a>));
00102   master-&gt;<a class="code" href="structstrbuf__s.html#o0">head</a>      = NULL;
00103   master-&gt;<a class="code" href="structstrbuf__s.html#o1">elements</a>  = 0;
00104   length            = 0;
00105 
00106   <span class="keywordflow">while</span> (*ptr)
00107   {
00108      <span class="comment">/*</span>
00109 <span class="comment">     * This works by moving through the string and replacing non-essential</span>
00110 <span class="comment">     * elements with NULL chars until the character designating an expansion</span>
00111 <span class="comment">     * mechanism is found.  The character is then sent off to MACRO_process</span>
00112 <span class="comment">     * for expansion</span>
00113 <span class="comment">    */</span>
00114     <span class="keywordflow">if</span> (*ptr == <span class="charliteral">'%'</span>) <span class="comment">/* start of macro */</span>
00115     {
00116       <span class="keywordflow">switch</span> (*(ptr + 1))
00117       {
00118         <span class="keywordflow">case</span> <span class="charliteral">'%'</span>:
00119 
00120           <span class="comment">/* convert %% into % */</span>
00121           <span class="keywordflow">if</span> (<a class="code" href="macro_8h.html#a4">MACRO_addbuf</a>(master, (<span class="keywordtype">char</span> *)macro_p, 1) == <a class="code" href="spf_8h.html#a87a49">SPF_FALSE</a>)
00122           {
00123             <a class="code" href="util_8h.html#a10">xvprintf</a>(<span class="stringliteral">"Unable to allocate list node with (%c)!\n"</span>, macro_p);
00124 
00125             <span class="keywordflow">return</span>(NULL);
00126           }
00127 
00128           ptr += 2;
00129           length++;
00130           <span class="keywordflow">break</span>;
00131 
00132         <span class="keywordflow">case</span> <span class="charliteral">'_'</span>:
00133 
00134           <span class="comment">/* convert %_ to a white space */</span>
00135           <span class="keywordflow">if</span> (<a class="code" href="macro_8h.html#a4">MACRO_addbuf</a>(master, (<span class="keywordtype">char</span> *)macro_u, 1) == <a class="code" href="spf_8h.html#a87a49">SPF_FALSE</a>)
00136           {
00137             <a class="code" href="util_8h.html#a10">xvprintf</a>(<span class="stringliteral">"Unable to allocate list node with (%c)!\n"</span>, macro_u);
00138 
00139             <span class="keywordflow">return</span>(NULL);
00140           }
00141 
00142           ptr += 2;
00143           length++;
00144           <span class="keywordflow">break</span>;
00145 
00146         <span class="keywordflow">case</span> <span class="charliteral">'-'</span>:
00147 
00148           <span class="comment">/* convert %- into URL encoded '%20' */</span>
00149           <span class="keywordflow">if</span> (<a class="code" href="macro_8h.html#a4">MACRO_addbuf</a>(master, (<span class="keywordtype">char</span> *)macro_d, 3) == <a class="code" href="spf_8h.html#a87a49">SPF_FALSE</a>)
00150           {
00151             <a class="code" href="util_8h.html#a10">xvprintf</a>(<span class="stringliteral">"Unable to allocate list node with (%s)!\n"</span>, macro_d);
00152 
00153             <span class="keywordflow">return</span>(NULL);
00154           }
00155 
00156           ptr    += 2;
00157           length += 3;
00158           <span class="keywordflow">break</span>;
00159 
00160         <span class="keywordflow">case</span> <span class="charliteral">'{'</span>:
00161 
00162           *ptr++ = <span class="charliteral">'\0'</span>; <span class="comment">/* % */</span>
00163           *ptr++ = <span class="charliteral">'\0'</span>; <span class="comment">/* { */</span>
00164 
00165           <span class="keywordflow">if</span> ((i = <a class="code" href="util_8h.html#a35">UTIL_index</a>(ptr, <span class="charliteral">'}'</span>)) == 0)
00166           {
00167             <a class="code" href="util_8h.html#a10">xvprintf</a>(<span class="stringliteral">"'}' Invalid Macro (%c)\n"</span>, *(s + 1));
00168 
00169             <span class="keywordflow">return</span>(NULL);  <span class="comment">/* not closed, invalid macro */</span>
00170           }
00171 
00172           *(ptr + i) = <span class="charliteral">'\0'</span>; <span class="comment">/* } */</span>
00173 
00174           <a class="code" href="util_8h.html#a10">xvprintf</a>(<span class="stringliteral">"Actual macro (%s)\n"</span>, ptr);
00175           <span class="keywordflow">if</span> ((macro = <a class="code" href="macro_8h.html#a2">MACRO_process</a>(p, ptr, (i + 1))) == NULL)
00176           {
00177             <a class="code" href="util_8h.html#a13">xepprintf</a>(<span class="stringliteral">"macro process returned null!\n"</span>);
00178           }
00179           <span class="keywordflow">else</span>
00180           {
00181             length += strlen(macro);
00182             <a class="code" href="util_8h.html#a10">xvprintf</a>(<span class="stringliteral">"Macro expanded to: (%s) %i bytes\n"</span>, macro,
00183               strlen(macro));
00184 
00185             <span class="keywordflow">if</span> (<a class="code" href="macro_8h.html#a4">MACRO_addbuf</a>(master, macro, strlen(macro)) == <a class="code" href="spf_8h.html#a87a49">SPF_FALSE</a>)
00186             {
00187               <a class="code" href="util_8h.html#a10">xvprintf</a>(<span class="stringliteral">"Unable to allocate list node with (%s)!\n"</span>, macro);
00188               <a class="code" href="util_8h.html#a6">xfree</a>(macro);
00189 
00190               <span class="keywordflow">return</span>(NULL);  <span class="comment">/* not closed, invalid macro */</span>
00191             }
00192             <a class="code" href="util_8h.html#a6">xfree</a>(macro);
00193           }
00194           ptr += i;
00195           <span class="keywordflow">break</span>;
00196 
00197         <span class="keywordflow">default</span>:
00198 
00199           <a class="code" href="util_8h.html#a10">xvprintf</a>(<span class="stringliteral">"ERROR: Invalid macro. (%s) Abort!\n"</span>, *(ptr + 1));
00200 
00201           <span class="comment">/* need cleanup function call perhaps */</span>
00202           <span class="keywordflow">return</span>(NULL);
00203           <span class="keywordflow">break</span>;
00204 
00205       } <span class="comment">/* switch */</span>
00206     } <span class="comment">/* if */</span>
00207     <span class="keywordflow">else</span>
00208     {
00209       <span class="keywordflow">if</span> ((i = <a class="code" href="util_8h.html#a35">UTIL_index</a>(ptr, <span class="charliteral">'%'</span>)) == 0)
00210       {
00211         <span class="keywordflow">while</span> (*(ptr + i))
00212         {
00213           i++;
00214         }
00215         s_macro = <a class="code" href="util_8h.html#a4">xmalloc</a>(i + 1);
00216         memcpy(s_macro, ptr, (i + 1));
00217       }
00218       <span class="keywordflow">else</span>
00219       {
00220         s_macro = <a class="code" href="util_8h.html#a4">xmalloc</a>(i + 1);
00221         memcpy(s_macro, ptr, i);
00222       }
00223 
00224       length += i;
00225 
00226       <span class="keywordflow">if</span> (<a class="code" href="macro_8h.html#a4">MACRO_addbuf</a>(master, s_macro, (i + 1)) == <a class="code" href="spf_8h.html#a87a49">SPF_FALSE</a>)
00227       {
00228         <a class="code" href="util_8h.html#a10">xvprintf</a>(<span class="stringliteral">"Unable to allocate list node with (%s)!\n"</span>, s_macro);
00229 
00230         <span class="keywordflow">return</span>(NULL);
00231       }
00232 
00233       ptr += (i - 1);
00234       <a class="code" href="util_8h.html#a10">xvprintf</a>(<span class="stringliteral">"Freeing s_macro temp buf (%s)\n"</span>, s_macro);
00235       <a class="code" href="util_8h.html#a6">xfree</a>(s_macro);
00236     }
00237     ptr++;
00238     <a class="code" href="util_8h.html#a10">xvprintf</a>(<span class="stringliteral">"Remaining buffer (%s)\n"</span>, ptr);
00239   } <span class="comment">/* while */</span>
00240 
00241   <a class="code" href="util_8h.html#a9">xprintf</a>(<span class="stringliteral">"Allocated %i bytes for return buf\n"</span>, length);
00242   buf = <a class="code" href="util_8h.html#a4">xmalloc</a>(length + 1);
00243 
00244   c_node = master-&gt;<a class="code" href="structstrbuf__s.html#o0">head</a>;
00245   <span class="keywordflow">while</span> (c_node != NULL)
00246   {
00247     kill_node = c_node;
00248 
00249     <span class="keywordflow">if</span> (kill_node-&gt;<a class="code" href="structstrbuf__node__s.html#o0">len</a> &gt; 1)
00250     {
00251       <a class="code" href="util_8h.html#a10">xvprintf</a>(<span class="stringliteral">"NODE: (%s) LEN: %i\n"</span>, kill_node-&gt;<a class="code" href="structstrbuf__node__s.html#o1">s</a>, kill_node-&gt;<a class="code" href="structstrbuf__node__s.html#o0">len</a>);
00252     }
00253     <span class="keywordflow">else</span>
00254     {
00255       <a class="code" href="util_8h.html#a10">xvprintf</a>(<span class="stringliteral">"NODE: (%c) LEN: %i\n"</span>, kill_node-&gt;<a class="code" href="structstrbuf__node__s.html#o1">s</a>, kill_node-&gt;<a class="code" href="structstrbuf__node__s.html#o0">len</a>);
00256     }
00257 
00258     strncat(buf, kill_node-&gt;<a class="code" href="structstrbuf__node__s.html#o1">s</a>, kill_node-&gt;<a class="code" href="structstrbuf__node__s.html#o0">len</a>);
00259     <a class="code" href="util_8h.html#a6">xfree</a>(kill_node-&gt;<a class="code" href="structstrbuf__node__s.html#o1">s</a>);
00260     c_node = c_node-&gt;next;
00261     <a class="code" href="util_8h.html#a6">xfree</a>(kill_node);
00262   }
00263 
00264   <a class="code" href="util_8h.html#a6">xfree</a>(cp);
00265   <a class="code" href="util_8h.html#a6">xfree</a>(master);
00266 
00267   <a class="code" href="util_8h.html#a10">xvprintf</a>(<span class="stringliteral">"Returning expanded macro: (%s)\n"</span>, buf);
00268 
00269   <span class="keywordflow">return</span>(buf);
00270 }
00271 
00272 
00273 <span class="comment">/* MACRO_process</span>
00274 <span class="comment">*</span>
00275 <span class="comment">*  Author: James Couzens &lt;jcouzens@codeshare.ca&gt;</span>
00276 <span class="comment">*</span>
00277 <span class="comment">*  Date:   01/21/04</span>
00278 <span class="comment">*</span>
00279 <span class="comment">*  Desc:</span>
00280 <span class="comment">*         This function takes a NULL terminated string containing only one</span>
00281 <span class="comment">*  macro. It returns a new string containing whatever that macro expanded to.</span>
00282 <span class="comment">*  Returns NULL if the macro can not be expanded.</span>
00283 <span class="comment">*</span>
00284 <span class="comment">*  exists:%{ir}.%{l1r+-}._spf.%{d}</span>
00285 <span class="comment">*</span>
00286 <span class="comment">*  Date:   08/??/04 - Travis Anderson &lt;tanderson@codeshare.ca&gt;</span>
00287 <span class="comment">*</span>
00288 <span class="comment">*  Desc:</span>
00289 <span class="comment">*          Fixed problematic 'p' macro with the addition of new DNS function</span>
00290 <span class="comment">*  DNS_check_client_reverse.</span>
00291 <span class="comment">*</span>
00292 <span class="comment">*  Date:   09/11/04 - James Couzens &lt;jcouzens@codeshare.ca&gt;</span>
00293 <span class="comment">*</span>
00294 <span class="comment">*  Desc:</span>
00295 <span class="comment">*          Removed strlen calls originally intended for replacement</span>
00296 <span class="comment">*  with either a generic limit (SPF_MAX_STR), or a more stringent limit safely</span>
00297 <span class="comment">*  imposed upon the malloc.</span>
00298 <span class="comment">*    </span>
00299 <span class="comment">*</span>
00300 <span class="comment">*/</span>
<a name="l00301"></a><a class="code" href="macro_8h.html#a2">00301</a> <span class="keywordtype">char</span> *<a class="code" href="macro_8h.html#a2">MACRO_process</a>(<a class="code" href="structpeer__info__s.html">peer_info_t</a> *p, <span class="keywordtype">char</span> *macro, <span class="keyword">const</span> size_t size)
00302 {
00303   <span class="keywordtype">int</span> c;             <span class="comment">/* stores a lower case version of the macro if necessary */</span>
00304 
00305   size_t i;          <span class="comment">/* utility for string lengths */</span>
00306 
00307   <span class="keywordtype">char</span> *rev_addr;    <span class="comment">/* used by p macro */</span>
00308 
00309 
00310   <span class="keywordflow">if</span> (macro == NULL)
00311   {
00312     <a class="code" href="util_8h.html#a13">xepprintf</a>(<span class="stringliteral">"Passed a NULL string.  Abort!\n"</span>);
00313 
00314     <span class="keywordflow">return</span>(<a class="code" href="spf_8h.html#a87a49">SPF_FALSE</a>);
00315   }
00316 
00317   <a class="code" href="util_8h.html#a9">xprintf</a>(<span class="stringliteral">"called with (%s) and len: %i\n"</span>,macro, size);
00318 
00319   rev_addr = NULL;
00320   i = 0;
00321 
00322   <span class="keywordflow">if</span> (isupper(*macro))
00323   {
00324     c = tolower(*macro);
00325   }
00326   <span class="keywordflow">else</span>
00327   {
00328     c = *macro;
00329   }
00330 
00331   <span class="keywordflow">switch</span> (c)
00332   {
00333     <span class="comment">/* */</span>
00334     <span class="keywordflow">case</span> <span class="charliteral">'d'</span>:
00335       <span class="keywordflow">if</span> (*(macro + 1))
00336       {
00337         <span class="keywordflow">return</span>(<a class="code" href="macro_8h.html#a3">MACRO_eatmore</a>(macro, p-&gt;<a class="code" href="structpeer__info__s.html#o15">current_domain</a>));
00338       }
00339       <span class="keywordflow">else</span>
00340       {
00341         <a class="code" href="util_8h.html#a10">xvprintf</a>(<span class="stringliteral">"macro 'd' expands to: (%s)\n"</span>,
00342           p-&gt;<a class="code" href="structpeer__info__s.html#o15">current_domain</a>);
00343 
00344         <span class="keywordflow">return</span>(<a class="code" href="util_8h.html#a8">xstrndup</a>(p-&gt;<a class="code" href="structpeer__info__s.html#o15">current_domain</a>, <a class="code" href="spf_8h.html#a5">SPF_MAX_STR</a>));
00345       }
00346     <span class="comment">/* */</span>
00347     <span class="keywordflow">case</span> <span class="charliteral">'h'</span>:
00348       <span class="keywordflow">if</span> (*(macro + 1))
00349       {
00350         <span class="keywordflow">return</span>(<a class="code" href="macro_8h.html#a3">MACRO_eatmore</a>(macro, p-&gt;<a class="code" href="structpeer__info__s.html#o8">helo</a>));
00351       }
00352       <span class="keywordflow">else</span>
00353       {
00354         <a class="code" href="util_8h.html#a10">xvprintf</a>(<span class="stringliteral">"macro 'h' expands to: (%s)\n"</span>, p-&gt;<a class="code" href="structpeer__info__s.html#o8">helo</a>);
00355 
00356         <span class="keywordflow">if</span> (p-&gt;<a class="code" href="structpeer__info__s.html#o8">helo</a> != NULL)
00357         {
00358           <span class="keywordflow">return</span>(<a class="code" href="util_8h.html#a8">xstrndup</a>(p-&gt;<a class="code" href="structpeer__info__s.html#o8">helo</a>, <a class="code" href="spf_8h.html#a13">SPF_MAX_ENV_HELO</a>));
00359         }
00360         <span class="keywordflow">else</span>
00361         {
00362           <span class="keywordflow">return</span>(<a class="code" href="util_8h.html#a8">xstrndup</a>(p-&gt;<a class="code" href="structpeer__info__s.html#o9">ehlo</a>, <a class="code" href="spf_8h.html#a13">SPF_MAX_ENV_HELO</a>));
00363         }
00364       }
00365     <span class="comment">/* */</span>
00366     <span class="keywordflow">case</span> <span class="charliteral">'i'</span>:
00367       <span class="keywordflow">if</span> (*(macro + 1))
00368       {
00369         <span class="keywordflow">return</span>(<a class="code" href="macro_8h.html#a3">MACRO_eatmore</a>(macro, p-&gt;<a class="code" href="structpeer__info__s.html#o17">r_ip</a>));
00370       }
00371       <span class="keywordflow">else</span>
00372       {
00373         <a class="code" href="util_8h.html#a10">xvprintf</a>(<span class="stringliteral">"macro 'i' expands to: (%s)\n"</span>, p-&gt;<a class="code" href="structpeer__info__s.html#o17">r_ip</a>);
00374 
00375         <span class="keywordflow">return</span>(<a class="code" href="util_8h.html#a8">xstrndup</a>(p-&gt;<a class="code" href="structpeer__info__s.html#o17">r_ip</a>, <a class="code" href="spf_8h.html#a11">SPF_MAX_IP_ADDR</a>));
00376       }
00377     <span class="comment">/* */</span>
00378     <span class="keywordflow">case</span> <span class="charliteral">'l'</span>:
00379       <span class="keywordflow">if</span> (*(macro + 1))
00380       {
00381         <span class="keywordflow">return</span>(<a class="code" href="macro_8h.html#a3">MACRO_eatmore</a>(macro, p-&gt;<a class="code" href="structpeer__info__s.html#o21">local_part</a>));
00382       }
00383       <span class="keywordflow">else</span>
00384       {
00385         <a class="code" href="util_8h.html#a10">xvprintf</a>(<span class="stringliteral">"macro 'l' expands to: (%s)\n"</span>, p-&gt;<a class="code" href="structpeer__info__s.html#o21">local_part</a>);
00386 
00387         <span class="keywordflow">return</span>(<a class="code" href="util_8h.html#a8">xstrndup</a>(p-&gt;<a class="code" href="structpeer__info__s.html#o21">local_part</a>, <a class="code" href="spf_8h.html#a7">SPF_MAX_LOCAL_PART</a>));
00388       }
00389     <span class="comment">/* */</span>
00390     <span class="keywordflow">case</span> <span class="charliteral">'o'</span>:
00391       <span class="keywordflow">if</span> (*(macro + 1))
00392       {
00393         <span class="keywordflow">return</span>(<a class="code" href="macro_8h.html#a3">MACRO_eatmore</a>(macro, p-&gt;<a class="code" href="structpeer__info__s.html#o15">current_domain</a>));
00394       }
00395       <span class="keywordflow">else</span>
00396       {
00397         <a class="code" href="util_8h.html#a10">xvprintf</a>(<span class="stringliteral">"macro 'o' expands to: (%s)\n"</span>,
00398           p-&gt;<a class="code" href="structpeer__info__s.html#o15">current_domain</a>);
00399 
00400         <span class="keywordflow">return</span>(<a class="code" href="util_8h.html#a8">xstrndup</a>(p-&gt;<a class="code" href="structpeer__info__s.html#o15">current_domain</a>, <a class="code" href="spf_8h.html#a5">SPF_MAX_STR</a>));
00401       }
00402     <span class="comment">/* */</span>
00403     <span class="keywordflow">case</span> <span class="charliteral">'p'</span>:
00404       <span class="keywordflow">if</span> (<a class="code" href="dns_8h.html#a13">DNS_check_client_reverse</a>(p) == <a class="code" href="spf_8h.html#a87a49">SPF_FALSE</a>)
00405       {
00406         p-&gt;<a class="code" href="structpeer__info__s.html#o18">r_vhname</a> = <a class="code" href="util_8h.html#a4">xmalloc</a>(8);
00407         snprintf(p-&gt;<a class="code" href="structpeer__info__s.html#o18">r_vhname</a>, 8, <span class="stringliteral">"unknown"</span>);
00408       }
00409 
00410       <span class="keywordflow">if</span> (*(macro + 1))
00411       {
00412         <a class="code" href="util_8h.html#a10">xvprintf</a>(<span class="stringliteral">"macro 'p' expands to: (%s)\n"</span>, p-&gt;<a class="code" href="structpeer__info__s.html#o18">r_vhname</a>);
00413 
00414         <span class="keywordflow">return</span>(<a class="code" href="macro_8h.html#a3">MACRO_eatmore</a>(macro, p-&gt;<a class="code" href="structpeer__info__s.html#o18">r_vhname</a>));
00415       }
00416       <span class="keywordflow">else</span>
00417       {
00418         <a class="code" href="util_8h.html#a10">xvprintf</a>(<span class="stringliteral">"macro 'p' expands to: (%s)\n"</span>, p-&gt;<a class="code" href="structpeer__info__s.html#o18">r_vhname</a>);
00419 
00420         <span class="keywordflow">return</span>(<a class="code" href="util_8h.html#a8">xstrndup</a>(p-&gt;<a class="code" href="structpeer__info__s.html#o18">r_vhname</a>, <a class="code" href="spf_8h.html#a5">SPF_MAX_STR</a>));
00421       }
00422     <span class="comment">/* */</span>
00423     <span class="keywordflow">case</span> <span class="charliteral">'s'</span>:
00424 
00425       <span class="keywordflow">if</span> ((p-&gt;<a class="code" href="structpeer__info__s.html#o19">cur_eaddr</a> != NULL) || p-&gt;<a class="code" href="structpeer__info__s.html#o19">cur_eaddr</a>)
00426       {
00427         <a class="code" href="util_8h.html#a6">xfree</a>(p-&gt;<a class="code" href="structpeer__info__s.html#o19">cur_eaddr</a>);
00428       }
00429 
00430       <a class="code" href="util_8h.html#a9">xprintf</a>(<span class="stringliteral">"local-part: (%s); current domain: (%s)\n"</span>,
00431         p-&gt;<a class="code" href="structpeer__info__s.html#o21">local_part</a>, p-&gt;<a class="code" href="structpeer__info__s.html#o15">current_domain</a>);
00432       i = ((strlen(p-&gt;<a class="code" href="structpeer__info__s.html#o21">local_part</a>) + strlen(p-&gt;<a class="code" href="structpeer__info__s.html#o15">current_domain</a>) + 2));
00433       p-&gt;<a class="code" href="structpeer__info__s.html#o19">cur_eaddr</a> = <a class="code" href="util_8h.html#a4">xmalloc</a>(i);
00434       snprintf(p-&gt;<a class="code" href="structpeer__info__s.html#o19">cur_eaddr</a>, i, <span class="stringliteral">"%s@%s"</span>,
00435         p-&gt;<a class="code" href="structpeer__info__s.html#o21">local_part</a>, p-&gt;<a class="code" href="structpeer__info__s.html#o15">current_domain</a>);
00436 
00437       <span class="keywordflow">if</span> (*(macro + 1))
00438       {
00439         <span class="keywordflow">return</span>(<a class="code" href="macro_8h.html#a3">MACRO_eatmore</a>(macro, p-&gt;<a class="code" href="structpeer__info__s.html#o19">cur_eaddr</a>));
00440       }
00441       <span class="keywordflow">else</span>
00442       {
00443         <a class="code" href="util_8h.html#a10">xvprintf</a>(<span class="stringliteral">"macro 's' expands to: (%s)\n"</span>, p-&gt;<a class="code" href="structpeer__info__s.html#o19">cur_eaddr</a>);
00444 
00445         <span class="keywordflow">return</span>(<a class="code" href="util_8h.html#a8">xstrndup</a>(p-&gt;<a class="code" href="structpeer__info__s.html#o19">cur_eaddr</a>, <a class="code" href="spf_8h.html#a5">SPF_MAX_STR</a>));
00446       }
00447     <span class="comment">/* */</span>
00448     <span class="keywordflow">case</span> <span class="charliteral">'t'</span>:
00449       <span class="keywordflow">if</span> (*(macro + 1))
00450       {
00451         <span class="keywordflow">return</span>(<a class="code" href="macro_8h.html#a3">MACRO_eatmore</a>(macro, p-&gt;<a class="code" href="structpeer__info__s.html#o22">utc_time</a>));
00452       }
00453       <span class="keywordflow">else</span>
00454       {
00455         <a class="code" href="util_8h.html#a10">xvprintf</a>(<span class="stringliteral">"macro 't' expands to: (%s)\n"</span>, p-&gt;<a class="code" href="structpeer__info__s.html#o22">utc_time</a>);
00456 
00457         <span class="keywordflow">return</span>(<a class="code" href="util_8h.html#a8">xstrndup</a>(p-&gt;<a class="code" href="structpeer__info__s.html#o22">utc_time</a>, <a class="code" href="spf_8h.html#a10">SPF_MAX_UTC_TIME</a>));
00458       }
00459     <span class="comment">/* */</span>
00460     <span class="keywordflow">case</span> <span class="charliteral">'v'</span>:
00461       <span class="keywordflow">if</span> (*(macro + 1))
00462       {
00463         <span class="keywordflow">return</span>(<a class="code" href="macro_8h.html#a3">MACRO_eatmore</a>(macro, p-&gt;<a class="code" href="structpeer__info__s.html#o20">ip_ver</a>));
00464       }
00465       <span class="keywordflow">else</span>
00466       {
00467         <a class="code" href="util_8h.html#a10">xvprintf</a>(<span class="stringliteral">"macro 'v' expands to: (%s)\n"</span>, p-&gt;<a class="code" href="structpeer__info__s.html#o20">ip_ver</a>);
00468         <span class="keywordflow">return</span>(<a class="code" href="util_8h.html#a8">xstrndup</a>(p-&gt;<a class="code" href="structpeer__info__s.html#o20">ip_ver</a>, <a class="code" href="spf_8h.html#a11">SPF_MAX_IP_ADDR</a>));
00469       }
00470     <span class="comment">/* */</span>
00471     <span class="keywordflow">case</span> <span class="charliteral">'x'</span>:
00472       <span class="keywordflow">if</span> (size &gt; 1)
00473       {
00474         <span class="keywordflow">if</span> (*(macro + 1) == <span class="charliteral">'R'</span> || *(macro + 1) == <span class="charliteral">'r'</span>)
00475         {
00476           <span class="keywordflow">return</span>(<a class="code" href="util_8h.html#a8">xstrndup</a>(p-&gt;<a class="code" href="structpeer__info__s.html#o16">mta_hname</a>, <a class="code" href="spf_8h.html#a14">SPF_MAX_HNAME</a>));
00477         }
00478       }
00479       <span class="keywordflow">break</span>;
00480 
00481     <span class="keywordflow">default</span>:
00482       <span class="keywordflow">return</span>(<a class="code" href="util_8h.html#a8">xstrndup</a>(macro, <a class="code" href="spf_8h.html#a5">SPF_MAX_STR</a>));
00483   } <span class="comment">/* switch */</span>
00484 
00485   <span class="keywordflow">return</span>(NULL);
00486 }
00487 
00488 
00489 <span class="comment">/* MACRO_eatmore</span>
00490 <span class="comment">*</span>
00491 <span class="comment">*  Author: James Couzens &lt;jcouzens@codeshare.ca&gt;</span>
00492 <span class="comment">*</span>
00493 <span class="comment">*  Date:   01/22/04</span>
00494 <span class="comment">*  Date:   07/02/04 James Couzens &lt;jcouzens@codeshare.ca&gt; (compiler warnings)</span>
00495 <span class="comment">*</span>
00496 <span class="comment">*  Desc:</span>
00497 <span class="comment">*         This function is called whenever a macro is more than one character</span>
00498 <span class="comment">*  long and so we have to 'eatmore' ;-)  macro is the unexpanded macro and</span>
00499 <span class="comment">*  s is the expanded string of the original macro would have been returned as</span>
00500 <span class="comment">*  had it been single.  Returns the expanded macro using dynamically allocated</span>
00501 <span class="comment">*  memory upon success and in the process will FREE s after allocating more</span>
00502 <span class="comment">*  memory (if necessary) and copying it over.  Returns NULL upon failure.</span>
00503 <span class="comment">*</span>
00504 <span class="comment">*/</span>
<a name="l00505"></a><a class="code" href="macro_8h.html#a3">00505</a> <span class="keywordtype">char</span> *<a class="code" href="macro_8h.html#a3">MACRO_eatmore</a>(<span class="keywordtype">char</span> *macro, <span class="keywordtype">char</span> *s)
00506 {
00507   size_t i;          <span class="comment">/* how much of the buffer we are using */</span>
00508 
00509   <span class="keywordtype">char</span> delim;        <span class="comment">/* marco is a delimiter modifier */</span>
00510 
00511   <span class="keywordtype">char</span> *cp;          <span class="comment">/* working pointer */</span>
00512   <span class="keywordtype">char</span> *buf;         <span class="comment">/* return buffer */</span>
00513   <span class="keywordtype">char</span> *rev_str;     <span class="comment">/* temporary buffer */</span>
00514   <span class="keywordtype">char</span> *d_buf;       <span class="comment">/* temporary buffer */</span>
00515 
00516   u_int8_t n_dot;    <span class="comment">/* number of 'delimiter' items in a string */</span>
00517   u_int8_t rev;      <span class="comment">/* string to be reversed */</span>
00518   u_int8_t digit;    <span class="comment">/* macro is a digit modifier */</span>
00519 
00520 
00521   <span class="keywordflow">if</span> (macro == NULL)
00522   {
00523     <a class="code" href="util_8h.html#a13">xepprintf</a>(<span class="stringliteral">"Passed a NULL string.  Abort!\n"</span>);
00524     <span class="keywordflow">return</span>(NULL);
00525   }
00526 
00527   <a class="code" href="util_8h.html#a9">xprintf</a>(<span class="stringliteral">"Called with macro (%s) and string (%s)\n"</span>, macro, s);
00528 
00529   <span class="comment">/* need a proper value for this not just SPF_MAX_MACRO need to know the MAXIMUM</span>
00530 <span class="comment">   * expandable length of a macro. */</span>
00531 
00532   cp      = macro;
00533   rev     = 0;
00534   digit   = 0;
00535   delim   = <span class="charliteral">'.'</span>;
00536   buf     = NULL;
00537   rev_str = NULL;
00538 
00539   <span class="keywordflow">while</span> (*cp)
00540   {
00541     <span class="keywordflow">if</span> (isdigit(*cp))
00542     {
00543       digit = atoi(cp);
00544     }
00545     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="util_8h.html#a39">UTIL_is_spf_delim</a>(*cp) == <a class="code" href="spf_8h.html#a87a50">SPF_TRUE</a>)
00546     {
00547       delim = *cp;
00548     }
00549     <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((*cp == <span class="charliteral">'r'</span>) || (*cp == <span class="charliteral">'R'</span>))
00550     {
00551       rev = 1;
00552     }
00553     cp++;
00554   }
00555 
00556   <a class="code" href="util_8h.html#a10">xvprintf</a>(<span class="stringliteral">"mac:(%s) r:(%i) dig:(%i) dlm: (%c)\n"</span>,
00557     macro, rev, digit, delim);
00558 
00559   i = 0;
00560   <span class="comment">/* reverse the string */</span>
00561   <span class="keywordflow">if</span> (rev == 1)
00562   {
00563     <span class="comment">/*delim = '.';*/</span>
00564     rev_str = <a class="code" href="util_8h.html#a56">UTIL_reverse</a>(s, delim);
00565     s = NULL;
00566   }
00567 
00568   <span class="keywordflow">if</span> (s == NULL)
00569   {
00570     cp = rev_str;
00571   }
00572   <span class="keywordflow">else</span>
00573   {
00574     cp = s;
00575   }
00576 
00577   <span class="comment">/* exercise digit modifier on string */</span>
00578   <span class="keywordflow">if</span> (digit &gt; 0)
00579   {
00580     n_dot = <a class="code" href="util_8h.html#a38">UTIL_count_delim</a>(cp, delim);
00581 
00582     <span class="keywordflow">if</span> (digit &gt; n_dot)
00583     {
00584       digit = n_dot;
00585     }
00586 
00587     <span class="keywordflow">if</span> ((d_buf = <a class="code" href="util_8h.html#a37">UTIL_split_strr</a>(cp, delim, digit)) != NULL)
00588     {
00589       i = strlen(d_buf);
00590     }
00591     <span class="keywordflow">else</span>
00592     {
00593       d_buf = cp;
00594       i = strlen(d_buf);
00595     }
00596 
00597     buf = <a class="code" href="util_8h.html#a4">xmalloc</a>(i + 1);
00598     memcpy(buf, d_buf, (i + 1));
00599 
00600     <span class="keywordflow">if</span> (d_buf != cp)
00601     {
00602       <a class="code" href="util_8h.html#a6">xfree</a>(d_buf);
00603     }
00604   }
00605   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (rev == 1)
00606   {
00607     buf = <a class="code" href="util_8h.html#a8">xstrndup</a>(rev_str, <a class="code" href="spf_8h.html#a4">SPF_MAX_MACRO</a>);
00608   }
00609 
00610   <a class="code" href="util_8h.html#a10">xvprintf</a>(<span class="stringliteral">"Returning (%s) (%i bytes)\n"</span>, buf, strlen(buf));
00611 
00612   <span class="keywordflow">if</span> (rev == 1)
00613   {
00614     <a class="code" href="util_8h.html#a6">xfree</a>(rev_str);
00615   }
00616 
00617   <span class="keywordflow">return</span>(buf);
00618 }
00619 
00620 
00621 <span class="comment">/* MACRO_addbuf</span>
00622 <span class="comment">*</span>
00623 <span class="comment">*  Author: Sean Comeau &lt;scomeau@obscurity.org&gt;</span>
00624 <span class="comment">*  Author: James Couznes &lt;jcouzens@codeshare.ca&gt;</span>
00625 <span class="comment">*</span>
00626 <span class="comment">*  Date:    01/18/04</span>
00627 <span class="comment">*  Updated: 01/24/04</span>
00628 <span class="comment">*</span>
00629 <span class="comment">*</span>
00630 <span class="comment">*  Desc:</span>
00631 <span class="comment">*         Appends nodes to a master list which is passed of type</span>
00632 <span class="comment">*  strbuf_t.  The nodes are of type strbuf_node_t and appended on</span>
00633 <span class="comment">*  the end and the list is reordered to reflect this.  Returns</span>
00634 <span class="comment">*  SPF_TRUE upon success and SPF_FALSE</span>
00635 <span class="comment">*  upon failure.</span>
00636 <span class="comment">*</span>
00637 <span class="comment">*/</span>
<a name="l00638"></a><a class="code" href="macro_8h.html#a4">00638</a> <a class="code" href="spf_8h.html#a35">SPF_BOOL</a> <a class="code" href="macro_8h.html#a4">MACRO_addbuf</a>(<a class="code" href="structstrbuf__s.html">strbuf_t</a> *master, <span class="keywordtype">char</span> *s, size_t size)
00639 {
00640   <a class="code" href="structstrbuf__node__s.html">strbuf_node_t</a> *c_node     = NULL;  <span class="comment">/* c_node working node */</span>
00641   <a class="code" href="structstrbuf__node__s.html">strbuf_node_t</a> *new_node   = NULL;  <span class="comment">/* newly allocated node */</span>
00642   <a class="code" href="structstrbuf__node__s.html">strbuf_node_t</a> *prev_node  = NULL;  <span class="comment">/* previous working node */</span>
00643 
00644 
00645   <span class="keywordflow">if</span> (s == NULL)
00646   {
00647     <a class="code" href="util_8h.html#a13">xepprintf</a>(<span class="stringliteral">"Passed a NULL string.  Abort!\n"</span>);
00648 
00649     <span class="keywordflow">return</span>(<a class="code" href="spf_8h.html#a87a49">SPF_FALSE</a>);
00650   }
00651 
00652   <a class="code" href="util_8h.html#a10">xvprintf</a>(<span class="stringliteral">"Called with (%s) %i (%i) bytes.\n"</span>, s, size, strlen(s));
00653 
00654   new_node    = <a class="code" href="util_8h.html#a4">xmalloc</a>(<a class="code" href="util_8h.html#a3">SIZEOF</a>(<a class="code" href="structstrbuf__node__s.html">strbuf_node_t</a>));
00655   new_node-&gt;<a class="code" href="structstrbuf__node__s.html#o1">s</a> = <a class="code" href="util_8h.html#a4">xmalloc</a>(size + 1);
00656 
00657   strncpy(new_node-&gt;<a class="code" href="structstrbuf__node__s.html#o1">s</a>, s, size);
00658   new_node-&gt;<a class="code" href="structstrbuf__node__s.html#o0">len</a>   = size;
00659   new_node-&gt;<a class="code" href="structstrbuf__node__s.html#o2">next</a>  = NULL;
00660 
00661   <a class="code" href="util_8h.html#a10">xvprintf</a>(<span class="stringliteral">"Added (%s) to node of len: %i)\n"</span>, new_node-&gt;<a class="code" href="structstrbuf__node__s.html#o1">s</a>,
00662     new_node-&gt;<a class="code" href="structstrbuf__node__s.html#o0">len</a>);
00663 
00664   prev_node = NULL;
00665   c_node    = master-&gt;<a class="code" href="structstrbuf__s.html#o0">head</a>;
00666 
00667   <span class="comment">/* reorder the list with the NEW element on the end */</span>
00668   <span class="keywordflow">while</span> (c_node != NULL)
00669   {
00670     prev_node = c_node;
00671     c_node    = c_node-&gt;<a class="code" href="structstrbuf__node__s.html#o2">next</a>;
00672   }
00673 
00674   <span class="keywordflow">if</span> (prev_node != NULL)
00675   {
00676     new_node-&gt;<a class="code" href="structstrbuf__node__s.html#o2">next</a>  = prev_node-&gt;<a class="code" href="structstrbuf__node__s.html#o2">next</a>;
00677     prev_node-&gt;<a class="code" href="structstrbuf__node__s.html#o2">next</a> = new_node;
00678   }
00679   <span class="keywordflow">else</span>
00680   {
00681     master-&gt;<a class="code" href="structstrbuf__s.html#o0">head</a> = new_node;
00682   }
00683 
00684   master-&gt;<a class="code" href="structstrbuf__s.html#o1">elements</a>++;
00685 
00686   <span class="keywordflow">return</span>(<a class="code" href="spf_8h.html#a87a50">SPF_TRUE</a>);
00687 }
00688 
00689 <span class="comment">/* end macro.c */</span>
00690 
</div></pre><hr size="1"><address style="align: right;"><small>Generated on Thu Sep 16 18:10:46 2004 for libSPF v1.0 by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 ></a> 1.3.8 </small></address>
</body>
</html>
