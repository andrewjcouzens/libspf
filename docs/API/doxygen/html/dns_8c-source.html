<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>libSPF v1.0: dns.c Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.8 -->
<div class="qindex">  <form class="search" action="search.php" method="get">
<a class="qindex" href="main.html">Main&nbsp;Page</a> | <a class="qindex" href="annotated.html">Data&nbsp;Structures</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Data&nbsp;Fields</a> | <a class="qindex" href="globals.html">Globals</a>  | <span class="search"><u>S</u>earch&nbsp;for&nbsp;<input class="search" type="text" name="query" value="" size="20" accesskey="s"/></span></form></div>
<h1>dns.c</h1><a href="dns_8c.html">Go to the documentation of this file.</a><pre class="fragment"><div>00001 <span class="comment">/* libspf - Sender Policy Framework library</span>
00002 <span class="comment">*</span>
00003 <span class="comment">*  ANSI C implementation of spf-draft-200405.txt</span>
00004 <span class="comment">*</span>
00005 <span class="comment">*  Author: James Couzens &lt;jcouzens@codeshare.ca&gt;</span>
00006 <span class="comment">*  Author: Sean Comeau &lt;scomeau@obscurity.org&gt;</span>
00007 <span class="comment">*</span>
00008 <span class="comment">*  File:   dns.c</span>
00009 <span class="comment">*  Desc:   DNS related functions</span>
00010 <span class="comment">*</span>
00011 <span class="comment">*  License:</span>
00012 <span class="comment">*</span>
00013 <span class="comment">*  The libspf Software License, Version 1.0</span>
00014 <span class="comment">*</span>
00015 <span class="comment">*  Copyright (c) 2004 James Couzens &amp; Sean Comeau  All rights</span>
00016 <span class="comment">*  reserved.</span>
00017 <span class="comment">*</span>
00018 <span class="comment">*  Redistribution and use in source and binary forms, with or without</span>
00019 <span class="comment">*  modification, are permitted provided that the following conditions</span>
00020 <span class="comment">*  are met:</span>
00021 <span class="comment">*</span>
00022 <span class="comment">*  1. Redistributions of source code must retain the above copyright</span>
00023 <span class="comment">*     notice, this list of conditions and the following disclaimer.</span>
00024 <span class="comment">*</span>
00025 <span class="comment">*  2. Redistributions in binary form must reproduce the above copyright</span>
00026 <span class="comment">*     notice, this list of conditions and the following disclaimer in</span>
00027 <span class="comment">*     the documentation and/or other materials provided with the</span>
00028 <span class="comment">*     distribution.</span>
00029 <span class="comment">*</span>
00030 <span class="comment">*  THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED</span>
00031 <span class="comment">*  WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES</span>
00032 <span class="comment">*  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE</span>
00033 <span class="comment">*  DISCLAIMED.  IN NO EVENT SHALL THE AUTHORS MAKING USE OF THIS LICESEN</span>
00034 <span class="comment">*  OR ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,</span>
00035 <span class="comment">*  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT</span>
00036 <span class="comment">*  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF</span>
00037 <span class="comment">*  USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND</span>
00038 <span class="comment">*  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,</span>
00039 <span class="comment">*  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT</span>
00040 <span class="comment">*  OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF</span>
00041 <span class="comment">*  SUCH DAMAGE.</span>
00042 <span class="comment">*</span>
00043 <span class="comment">*/</span>
00044 
00045 
00046 <span class="preprocessor">#ifdef _WITH_PTHREADS</span>
00047 <span class="preprocessor"></span><span class="preprocessor">#include &lt;pthread.h&gt;</span>          <span class="comment">/* pthread_mutex_t */</span>
00048 <span class="preprocessor">  #ifdef HAVE_GETHOSTBYNAME_R</span>
00049 <span class="preprocessor"></span><span class="preprocessor">#include &lt;errno.h&gt;</span>            <span class="comment">/* errno */</span>
00050 <span class="preprocessor">  #endif </span><span class="comment">/* HAVE_GETHOSTBYNAME_R */</span>
00051 <span class="preprocessor">#endif </span><span class="comment">/* _WITH_PTHREADS */</span>
00052 
00053 <span class="preprocessor">#include "<a class="code" href="spf_8h.html">spf.h</a>"</span>              <span class="comment">/* SPF */</span>
00054 <span class="preprocessor">#include "<a class="code" href="util_8h.html">util.h</a>"</span>             <span class="comment">/* Utility functions */</span>
00055 <span class="preprocessor">#include "<a class="code" href="dns_8h.html">dns.h</a>"</span>              <span class="comment">/* our header */</span>
00056 <span class="preprocessor">#include "../../config.h"</span>     <span class="comment">/* autoconf */</span>
00057 
00058 <span class="preprocessor">#ifdef _WITH_PTHREADS</span>
00059 <span class="preprocessor"></span>
00060 <span class="comment">/* mutex for gethostbyname wrapper */</span>
00061 pthread_mutex_t <a class="code" href="dns_8c.html#a0">dns_mutex</a> = PTHREAD_MUTEX_INITIALIZER;
00062 
00063 <span class="preprocessor">  #ifdef HAVE_GETHOSTBYNAME_R</span>
00064 <span class="preprocessor"></span>
00065 <span class="comment">/* used by gethostbyname_r */</span>
00066 <span class="keyword">extern</span> <span class="keywordtype">int</span> <a class="code" href="util_8c.html#a1">errno</a>;
00067 
00068 <span class="preprocessor">  #endif </span><span class="comment">/* HAVE_GETHOSTBYNAME_R */</span>
00069 <span class="preprocessor">#else</span>
00070 <span class="preprocessor"></span>
00071 <span class="comment">/* mutex for gethostbyname dummy wrapper */</span>
<a name="l00072"></a><a class="code" href="dns_8c.html#a0">00072</a> <span class="keywordtype">void</span> *<a class="code" href="dns_8c.html#a0">dns_mutex</a>;
00073 
00074 <span class="preprocessor">#endif </span><span class="comment">/* _WITH_PTHREADS */</span>
00075 
00076 
00202 <span class="comment">/* DNS_query</span>
00203 <span class="comment">*</span>
00204 <span class="comment">* Author: James Couzens &lt;jcouzens@codeshare.ca&gt;\n</span>
00205 <span class="comment">* Author: Travis Anderson &lt;tanderson@codeshare.ca&gt;\n</span>
00206 <span class="comment">*</span>
00207 <span class="comment">* Date:   12/10/03</span>
00208 <span class="comment">* Date:   02/20/04 - Added cache by Travis Anderson &lt;tanderson@codeshare.ca&gt;</span>
00209 <span class="comment">*</span>
00210 <span class="comment">* Desc:</span>
00211 <span class="comment">*         Executes a DNS query of type T_TYPE and then calls the</span>
00212 <span class="comment">* appropriate answer parsing function based on that type.  Returns</span>
00213 <span class="comment">* a pointer to allocated memory (a string of space delimited</span>
00214 <span class="comment">* records).  Upon failure returns NULL.</span>
00215 <span class="comment">*</span>
00216 <span class="comment">*/</span>
<a name="l00217"></a><a class="code" href="dns_8h.html#a8">00217</a> <span class="keywordtype">char</span> *<a class="code" href="dns_8h.html#a8">DNS_query</a>(<a class="code" href="structpeer__info__s.html">peer_info_t</a> *p, <span class="keyword">const</span> <span class="keywordtype">char</span> *s, <span class="keyword">const</span> <span class="keywordtype">int</span> T_TYPE,
00218   <span class="keyword">const</span> <span class="keywordtype">char</span> *mta)
00219 {
00220   HEADER *hdr;                  <span class="comment">/* pointer to the header of the packet */</span>
00221 
00222   int8_t ancount;               <span class="comment">/* number of answers */</span>
00223 
00224   int16_t r_len;                <span class="comment">/* res_search return code &amp; packet len */</span>
00225   int16_t rc;                   <span class="comment">/* generic return code / length of */</span>
00226 
00227   <span class="keywordtype">int</span> ttl;                      <span class="comment">/* answer TTL */</span>
00228 
00229   <span class="keywordtype">char</span> buf[<a class="code" href="dns_8h.html#a2">SPF_MAXDNAME</a>];       <span class="comment">/* record extraction buffer */</span>
00230   <span class="keywordtype">char</span> answer[<a class="code" href="dns_8h.html#a1">SPF_PACKETSZ</a>];    <span class="comment">/* answer buffer */</span>
00231 
00232   <span class="keywordtype">char</span> *rr_data = NULL;         <span class="comment">/* record */</span>
00233 
00234   u_char *msg_ptr;              <span class="comment">/* pointer to beginning of the message */</span>
00235   u_char *eom_ptr;              <span class="comment">/* pointer to the end of the message */</span>
00236   u_char *rd_ptr;               <span class="comment">/* pointer to uncompressed message */</span>
00237 
00238 
00239   <span class="keywordflow">if</span> (s == NULL)
00240   {
00241     <a class="code" href="util_8h.html#a13">xepprintf</a>(<span class="stringliteral">"Passed a NULL char.  Aborting.\n"</span>);
00242     <span class="keywordflow">return</span>(NULL);
00243   }
00244 
00245   <a class="code" href="util_8h.html#a9">xprintf</a>(<span class="stringliteral">"Called with (%s) and type: %i\n"</span>, s, T_TYPE);
00246 
00247   r_len = res_search(s, C_IN, T_TYPE, (u_char *)answer, <a class="code" href="dns_8h.html#a1">SPF_PACKETSZ</a>);
00248 
00249   <span class="keywordflow">if</span> (r_len &lt;= 0)
00250   {
00251     <span class="keywordflow">switch</span> (<a class="code" href="dns_8h.html#a6">h_errno</a>)
00252     {
00253       <span class="keywordflow">case</span> HOST_NOT_FOUND:
00254         snprintf(p-&gt;<a class="code" href="structpeer__info__s.html#o24">error</a>, <a class="code" href="spf_8h.html#a16">SPF_MAX_ERROR</a>, <span class="stringliteral">"%s\n"</span>, hstrerror(<a class="code" href="dns_8h.html#a6">h_errno</a>));
00255         <a class="code" href="util_8h.html#a47">UTIL_assoc_prefix</a>(p, <a class="code" href="spf_8h.html#a88a52">SPF_NONE</a>, NULL);
00256         <a class="code" href="util_8h.html#a10">xvprintf</a>(<span class="stringliteral">"%s\n"</span>, p-&gt;<a class="code" href="structpeer__info__s.html#o24">error</a>);
00257 
00258         <span class="keywordflow">return</span>(NULL);
00259 
00260       <span class="keywordflow">case</span> TRY_AGAIN:
00261         snprintf(p-&gt;<a class="code" href="structpeer__info__s.html#o24">error</a>, <a class="code" href="spf_8h.html#a16">SPF_MAX_ERROR</a>, <span class="stringliteral">"%s\n"</span>, hstrerror(<a class="code" href="dns_8h.html#a6">h_errno</a>));
00262         <a class="code" href="util_8h.html#a47">UTIL_assoc_prefix</a>(p, <a class="code" href="spf_8h.html#a88a52">SPF_NONE</a>, NULL);
00263         <a class="code" href="util_8h.html#a10">xvprintf</a>(<span class="stringliteral">"%s\n"</span>, p-&gt;<a class="code" href="structpeer__info__s.html#o24">error</a>);
00264 
00265         <span class="keywordflow">return</span>(NULL);
00266 
00267       <span class="keywordflow">case</span> NO_RECOVERY:
00268         snprintf(p-&gt;<a class="code" href="structpeer__info__s.html#o24">error</a>, <a class="code" href="spf_8h.html#a16">SPF_MAX_ERROR</a>, <span class="stringliteral">"%s\n"</span>, hstrerror(<a class="code" href="dns_8h.html#a6">h_errno</a>));
00269         <a class="code" href="util_8h.html#a47">UTIL_assoc_prefix</a>(p, <a class="code" href="spf_8h.html#a88a55">SPF_ERROR</a>, NULL);
00270         <a class="code" href="util_8h.html#a10">xvprintf</a>(<span class="stringliteral">"%s\n"</span>, p-&gt;<a class="code" href="structpeer__info__s.html#o24">error</a>);
00271 
00272         <span class="keywordflow">return</span>(NULL);
00273 
00274       <span class="keywordflow">case</span> NO_DATA:
00275         snprintf(p-&gt;<a class="code" href="structpeer__info__s.html#o24">error</a>, <a class="code" href="spf_8h.html#a16">SPF_MAX_ERROR</a>, <span class="stringliteral">"%s\n"</span>, hstrerror(<a class="code" href="dns_8h.html#a6">h_errno</a>));
00276         <a class="code" href="util_8h.html#a47">UTIL_assoc_prefix</a>(p, <a class="code" href="spf_8h.html#a88a52">SPF_NONE</a>, NULL);
00277         <a class="code" href="util_8h.html#a10">xvprintf</a>(<span class="stringliteral">"%s\n"</span>, p-&gt;<a class="code" href="structpeer__info__s.html#o24">error</a>);
00278 
00279         <span class="keywordflow">return</span>(NULL);
00280 
00281       <span class="keywordflow">default</span>:
00282         snprintf(p-&gt;<a class="code" href="structpeer__info__s.html#o24">error</a>, <a class="code" href="spf_8h.html#a16">SPF_MAX_ERROR</a>, <span class="stringliteral">"%s\n"</span>, hstrerror(<a class="code" href="dns_8h.html#a6">h_errno</a>));
00283         <a class="code" href="util_8h.html#a47">UTIL_assoc_prefix</a>(p, <a class="code" href="spf_8h.html#a88a55">SPF_ERROR</a>, NULL);
00284         <a class="code" href="util_8h.html#a10">xvprintf</a>(<span class="stringliteral">"%s\n"</span>, p-&gt;<a class="code" href="structpeer__info__s.html#o24">error</a>);
00285 
00286         <span class="keywordflow">return</span>(NULL);
00287     } <span class="comment">/* switch */</span>
00288   }
00289 
00290   hdr     = (HEADER *)&amp;answer;
00291   ancount = ntohs(hdr-&gt;ancount);
00292 
00293   <a class="code" href="util_8h.html#a10">xvprintf</a>(<span class="stringliteral">"Received packet size of %i bytes which contains %i answers.\n"</span>,
00294     r_len, ancount);
00295 
00296   <a class="code" href="util_8h.html#a10">xvprintf</a>(<span class="stringliteral">"ANSWERS: %i\n"</span>, ancount);
00297   <a class="code" href="util_8h.html#a10">xvprintf</a>(<span class="stringliteral">"QUESTIONS: %i\n"</span>, ntohs(hdr-&gt;qdcount));
00298 
00299   <span class="keywordflow">if</span> (ancount &gt; 0)
00300   {
00301     msg_ptr = (u_char *)&amp;answer;               <span class="comment">/* point to start of message */</span>
00302     eom_ptr = (u_char *)&amp;answer + r_len;       <span class="comment">/* point to end of message */</span>
00303     rd_ptr  = (u_char *)&amp;answer + HFIXEDSZ;    <span class="comment">/* point to start of RDATA */</span>
00304 
00305     <span class="keywordflow">if</span> ((rc = dn_skipname(rd_ptr, eom_ptr)) &lt; 0)
00306     {
00307       <a class="code" href="util_8h.html#a13">xepprintf</a>(<span class="stringliteral">"Error obtaining QUESTION!\n"</span>);
00308 
00309       <span class="keywordflow">return</span>(NULL);
00310     }
00311 
00312     rd_ptr += rc + QFIXEDSZ;    <span class="comment">/* jump to start of ANSWER */</span>
00313 
00314     <span class="keywordflow">switch</span> (T_TYPE)
00315     {
00316        <span class="comment">/*</span>
00317 <span class="comment">       * T_A: A 'a' or address record used to associate an IP address with any</span>
00318 <span class="comment">       *      given hostname.</span>
00319 <span class="comment">      */</span>
00320       <span class="keywordflow">case</span> T_A:
00321         <span class="keywordflow">return</span>((<span class="keywordtype">char</span> *)<a class="code" href="spf_8h.html#a87a50">SPF_TRUE</a>);
00322 
00323        <span class="comment">/*</span>
00324 <span class="comment">       * T_TXT: A 'txt' or TEXT record which is what is currently used to store</span>
00325 <span class="comment">       *        the SPF records within DNS.  Its unfortunate that this had to be done</span>
00326 <span class="comment">       *        because you'll discover that I had to make concessions to deal with</span>
00327 <span class="comment">       *        the fact that many people publish more than just SPF records using</span>
00328 <span class="comment">       *        the T_TXT record type, especially considering it was seeing use long</span>
00329 <span class="comment">       *        before SPF ever came on the scene.  Hopefully this will change in the</span>
00330 <span class="comment">       *        near future.</span>
00331 <span class="comment">      */</span>
00332       <span class="keywordflow">case</span> T_TXT:
00333         <span class="keywordflow">if</span> ((rr_data = <a class="code" href="dns_8h.html#a9">DNS_txt_answer</a>(ancount, (u_char *)msg_ptr, (u_char *)eom_ptr,
00334           (u_char *)rd_ptr, buf, &amp;ttl)) == NULL)
00335         {
00336           <span class="keywordflow">return</span>(NULL);
00337         }
00338         <span class="keywordflow">break</span>;
00339 
00340       <span class="comment">/*</span>
00341 <span class="comment">       * T_MX: A 'mx' or Mail Exchanger (Server) record identifies an authorative</span>
00342 <span class="comment">       *       mail server (or in multiples server(s)) which may be used to deliver</span>
00343 <span class="comment">       *       e-mail to a given domain.</span>
00344 <span class="comment">      */</span>
00345       <span class="keywordflow">case</span> T_MX:
00346         <span class="keywordflow">if</span> ((rr_data = <a class="code" href="dns_8h.html#a10">DNS_mx_answer</a>(ancount, (u_char *)msg_ptr, (u_char *)eom_ptr,
00347           (u_char *)rd_ptr, buf, &amp;ttl)) == NULL)
00348         {
00349           <span class="keywordflow">return</span>(NULL);
00350         }
00351       <span class="keywordflow">break</span>;
00352 
00353       <span class="comment">/*</span>
00354 <span class="comment">      * T_PTR: A 'ptr' DNS record contains the reverse address for a</span>
00355 <span class="comment">      *        given hostname in the format x.x.x.x-in-addr.arpa in the</span>
00356 <span class="comment">      *        case of IPv4.</span>
00357 <span class="comment">     */</span>
00358       <span class="keywordflow">case</span> T_PTR:
00359 
00360          <span class="comment">/*</span>
00361 <span class="comment">         * Comment by: James Couzens &lt;jcouzens@codeshare.ca&gt;</span>
00362 <span class="comment">         * Date:       01/04/04</span>
00363 <span class="comment">         *</span>
00364 <span class="comment">         * DNS_ptr_answer doesn't allocate any memory and returns SPF_TRUE or</span>
00365 <span class="comment">         * SPF_FALSE, however this function returns a char so a the boolean </span>
00366 <span class="comment">         * value of SPF_TRUE/FALSE is cast to avoid writing a handler for </span>
00367 <span class="comment">         * this one specific instance.  I might change this in the future by</span>
00368 <span class="comment">         * either altering its return type or something else but for now this</span>
00369 <span class="comment">         * seems to do nicely.</span>
00370 <span class="comment">        */</span>
00371         <span class="keywordflow">if</span> (<a class="code" href="dns_8h.html#a11">DNS_ptr_answer</a>(p, ancount, (u_char *)msg_ptr, (u_char *)eom_ptr,
00372           (u_char *)rd_ptr, buf, mta, &amp;ttl) == <a class="code" href="spf_8h.html#a87a49">SPF_FALSE</a>)
00373         {
00374           <span class="keywordflow">return</span>((<span class="keywordtype">char</span> *)<a class="code" href="spf_8h.html#a87a49">SPF_FALSE</a>);
00375         }
00376         <span class="keywordflow">else</span>
00377         {
00378           <span class="keywordflow">return</span>((<span class="keywordtype">char</span> *)<a class="code" href="spf_8h.html#a87a50">SPF_TRUE</a>);
00379         }
00380         <span class="keywordflow">break</span>;
00381 
00382        <span class="comment">/*</span>
00383 <span class="comment">       * T_CNAME: A 'cname' or an alias record for a DNS forward or reverse</span>
00384 <span class="comment">       *          record which has been assigned more than one value.</span>
00385 <span class="comment">      */</span>
00386       <span class="keywordflow">case</span> T_CNAME:
00387         <span class="keywordflow">if</span> ((rr_data = <a class="code" href="dns_8h.html#a12">DNS_cname_answer</a>(ancount, (u_char *)msg_ptr, (u_char *)eom_ptr,
00388           (u_char *)rd_ptr, buf, &amp;ttl)) == NULL)
00389         {
00390           <span class="keywordflow">return</span>(NULL);
00391         }
00392         <span class="keywordflow">break</span>;
00393       <span class="keywordflow">default</span>:
00394         <span class="keywordflow">break</span>;
00395     }
00396     <span class="keywordflow">return</span>(rr_data);
00397   }
00398 
00399   <span class="keywordflow">return</span>(NULL);
00400 }
00401 
00402 
00403 <span class="comment">/* DNS_txt_answer</span>
00404 <span class="comment">*</span>
00405 <span class="comment">*  Author: James Couzens &lt;jcouzens@codeshare.ca&gt;</span>
00406 <span class="comment">*</span>
00407 <span class="comment">*  Date:   01/02/04</span>
00408 <span class="comment">*  Date:   02/23/04 - Bugfix from Albert Weichselbraun &lt;albert@atnet.at&gt;</span>
00409 <span class="comment">*  Date:   02/20/04 - Added cache by Travis Anderson &lt;tanderson@codeshare.ca&gt;</span>
00410 <span class="comment">*</span>
00411 <span class="comment">*  Desc:</span>
00412 <span class="comment">*          SPF_PACKETSZ bytes are allocated and then filled with \0 chars.</span>
00413 <span class="comment">*  This buffer is then used in a TXT DNS query using data from the passed</span>
00414 <span class="comment">*  peer_info_t structure.  Upon success this buffer is re-cast as a char *</span>
00415 <span class="comment">*  and then a pointer to this memory is returned.  Upon failure a NULL</span>
00416 <span class="comment">*  pointer is returned.</span>
00417 <span class="comment">*</span>
00418 <span class="comment">*/</span>
<a name="l00419"></a><a class="code" href="dns_8h.html#a9">00419</a> <span class="keywordtype">char</span> *<a class="code" href="dns_8h.html#a9">DNS_txt_answer</a>(int16_t ancount, <span class="keyword">const</span> u_char *msg_ptr,
00420   <span class="keyword">const</span> u_char *eom_ptr, u_char *rd_ptr, <span class="keywordtype">char</span> *buf, <span class="keywordtype">int</span> *ttl)
00421 {
00422   int16_t i;               <span class="comment">/* utility */</span>
00423   int16_t j;               <span class="comment">/* utility */</span>
00424   int16_t rc;              <span class="comment">/* generic return code / length of */</span>
00425   int16_t rd_type;         <span class="comment">/* answer type */</span>
00426   int16_t rd_len;          <span class="comment">/* res_search return code &amp; packet len */</span>
00427 
00428   int32_t rd_ttl;          <span class="comment">/* TTL */</span>
00429 
00430   <span class="keywordtype">char</span> *rr_data = NULL;    <span class="comment">/* data pointer */</span>
00431   <span class="keywordtype">char</span> *r_buf   = NULL;    <span class="comment">/* return buffer */</span>
00432   <span class="keywordtype">char</span> *pos     = NULL;    <span class="comment">/* utility pointer */</span>
00433 
00434 
00435   <span class="keywordflow">if</span> ((msg_ptr == NULL) || (eom_ptr == NULL) ||
00436       (rd_ptr == NULL)  || (buf == NULL))
00437   {
00438     <a class="code" href="util_8h.html#a13">xepprintf</a>(<span class="stringliteral">"Called with NULL pointers\n"</span>);
00439     <span class="keywordflow">return</span>(NULL);
00440   }
00441 
00442   <a class="code" href="util_8h.html#a11">xpprintf</a>(<span class="stringliteral">"entering function\n"</span>);
00443 
00444   i = 0;
00445   j = ancount;
00446   <span class="keywordflow">while</span> ((ancount &gt; 0) &amp;&amp; (rd_ptr &lt; eom_ptr))
00447   {
00448     <span class="keywordflow">if</span> ((rc = dn_expand(msg_ptr, eom_ptr, rd_ptr, buf, <a class="code" href="dns_8h.html#a3">SPF_MAXCDNAME</a>)) &lt; 0)
00449     {
00450       <a class="code" href="util_8h.html#a10">xvprintf</a>(<span class="stringliteral">"Unable to expand T_TXT response packet!; Reason: %s\n"</span>,
00451         hstrerror(<a class="code" href="dns_8h.html#a6">h_errno</a>));
00452 
00453       <span class="keywordflow">if</span> (rr_data != NULL)
00454       {
00455         <a class="code" href="util_8h.html#a6">xfree</a>(rr_data);
00456       }
00457 
00458       <span class="keywordflow">return</span>(NULL);
00459     }
00460 
00461     <span class="comment">/* dname, type, class, TTL, rdata len, rdata */</span>
00462     rd_ptr += rc;                 <span class="comment">/* jump to start of ANSWER data */</span>
00463     GETSHORT(rd_type, rd_ptr);    <span class="comment">/* get response type */</span>
00464     rd_ptr += INT16SZ;            <span class="comment">/* skip class */</span>
00465     GETLONG(rd_ttl, rd_ptr);      <span class="comment">/* get TTL */</span>
00466     GETSHORT(rd_len, rd_ptr);     <span class="comment">/* get data length */</span>
00467 
00468     *ttl = rd_ttl;                <span class="comment">/* TTL working pointer */</span>
00469 
00470     <span class="keywordflow">if</span> (rd_type != T_TXT)
00471     {
00472       <a class="code" href="util_8h.html#a10">xvprintf</a>(<span class="stringliteral">"Ignoring record not of T_TXT type. (%i)\n"</span>, rd_type);
00473       rd_ptr += rd_len;
00474       <span class="keywordflow">continue</span>;
00475     }
00476 
00477     rd_ptr++;                    <span class="comment">/* skip byte */</span>
00478 
00479     rd_ptr[rd_len]     = <span class="charliteral">'\0'</span>;
00480     rd_ptr[rd_len - 1] = <span class="charliteral">' '</span>;
00481 
00482     i += rd_len;
00483 
00484     <a class="code" href="util_8h.html#a10">xvprintf</a>(<span class="stringliteral">"Answer %i has length %i. (%i)\n"</span>, ancount, rd_len, i);
00485 
00486     <span class="comment">/*</span>
00487 <span class="comment">     * Only received one answer, so this MUST start with v=spf1 or its</span>
00488 <span class="comment">     * not a valid SPFv1 record</span>
00489 <span class="comment">    */</span>
00490     <span class="keywordflow">if</span> ((j == 1) &amp;&amp; ((*rd_ptr != <span class="charliteral">'v'</span>) &amp;&amp; (*(rd_ptr + 1) != <span class="charliteral">'='</span>)))
00491     {
00492       <a class="code" href="util_8h.html#a10">xvprintf</a>(<span class="stringliteral">"INVALID Answer Data: (%s) len: %i\n"</span>, rd_ptr, rd_len);
00493 
00494       <span class="keywordflow">if</span> (rr_data != NULL)
00495       {
00496         <a class="code" href="util_8h.html#a6">xfree</a>(rr_data);
00497       }
00498 
00499       <span class="keywordflow">return</span>(NULL);
00500     }
00501 
00502     <a class="code" href="util_8h.html#a10">xvprintf</a>(<span class="stringliteral">"Answer Data: (%s) len: %i\n"</span>, rd_ptr, rd_len);
00503 
00504     <span class="keywordflow">if</span> ((rd_len &lt;= SPF_MAXDNAME) &amp;&amp; (rd_len &gt; 0))
00505     {
00506       <span class="keywordflow">if</span> (rr_data == NULL)
00507       {
00508         rr_data = <a class="code" href="util_8h.html#a4">xmalloc</a>(i + 1);
00509       }
00510       <span class="keywordflow">else</span>
00511       {
00512         rr_data = <a class="code" href="util_8h.html#a5">xrealloc</a>(rr_data, (i + 1));
00513       }
00514 
00515       <a class="code" href="util_8h.html#a10">xvprintf</a>(<span class="stringliteral">"REALLOCATE memory: %i bytes\n"</span>, i);
00516 
00517       strncat(rr_data, (<span class="keywordtype">char</span> *)rd_ptr, rd_len);
00518       rr_data[i - 1] = <span class="charliteral">' '</span>;
00519       rr_data[i] = <span class="charliteral">'\0'</span>;
00520     }
00521 
00522     rd_ptr += rd_len;
00523     ancount--;
00524   }
00525 
00526   <span class="keywordflow">if</span> (rr_data == NULL)
00527   {
00528     <a class="code" href="util_8h.html#a11">xpprintf</a>(<span class="stringliteral">"rr_data is NULL (no ANSWERS in packet(s)), returning\n"</span>);
00529 
00530     <span class="keywordflow">return</span>(NULL);
00531   }
00532 
00533   rr_data[i] = <span class="charliteral">'\0'</span>;
00534 
00535   <a class="code" href="util_8h.html#a10">xvprintf</a>(<span class="stringliteral">"RR_DATA: (%s)\n"</span>, rr_data);
00536 
00537    <span class="comment">/*</span>
00538 <span class="comment">   *  Comment: James Couzens &lt;jcouzens@codeshare.ca&gt;</span>
00539 <span class="comment">   *</span>
00540 <span class="comment">   *  Date: 09/08/04</span>
00541 <span class="comment">   *</span>
00542 <span class="comment">   *  if: see if the string STARTS with v=spf1 </span>
00543 <span class="comment">   *  else: see if the string CONTAINS v=spf1 </span>
00544 <span class="comment">   *</span>
00545 <span class="comment">   *  Whats all this?!  This is because of the way DNS packets return -- that is</span>
00546 <span class="comment">   *  in random order.  This is of consequence because of the wording in the RFC.</span>
00547 <span class="comment">   *  That wording is that the version identifier may only appear once withing any</span>
00548 <span class="comment">   *  given SPF record (this makes sense) and that should it appear twice, this</span>
00549 <span class="comment">   *  is considered a violation (also makes sense). The point here is that as a</span>
00550 <span class="comment">   *  result of records returning out of order (then how they were declared in</span>
00551 <span class="comment">   *  the server's configuration that they were requested from) and how this </span>
00552 <span class="comment">   *  particular implementation deals with the DNS packets (they are concatenated</span>
00553 <span class="comment">   *  in the order in which they were received) the following code facilitates an</span>
00554 <span class="comment">   *  early pre-parse check to see if its even a valid SPF record.</span>
00555 <span class="comment">   *</span>
00556 <span class="comment">  */</span>
00557   <span class="keywordflow">if</span> ((*rr_data == <span class="charliteral">'v'</span>) &amp;&amp;
00558       (*(rr_data + 1) == <span class="charliteral">'='</span>) &amp;&amp;
00559       (*(rr_data + 2) == <span class="charliteral">'s'</span>) &amp;&amp;
00560       (*(rr_data + 3) == <span class="charliteral">'p'</span>) &amp;&amp;
00561       (*(rr_data + 4) == <span class="charliteral">'f'</span>) &amp;&amp;
00562       (*(rr_data + 5) == <span class="charliteral">'1'</span>))
00563   {
00564     <a class="code" href="util_8h.html#a10">xvprintf</a>(<span class="stringliteral">"Returning with valid SPFv1 record: (%s)\n"</span>, rr_data);
00565 
00566     <span class="keywordflow">return</span>(rr_data);
00567   }
00568   <span class="keywordflow">else</span>
00569   {
00570     <span class="comment">/* search the buffer for a valid SPFv1 version mechanism */</span>
00571     <span class="keywordflow">if</span> ((pos = strstr(rr_data, <span class="stringliteral">"v=spf1"</span>)) != NULL)
00572     {
00573       <a class="code" href="util_8h.html#a10">xvprintf</a>(<span class="stringliteral">"Found SPFv1 version mechanism: (%s)\n"</span>, pos);
00574 
00575       r_buf = <a class="code" href="util_8h.html#a8">xstrndup</a>(pos, <a class="code" href="spf_8h.html#a5">SPF_MAX_STR</a>);
00576       r_buf[strlen(pos)] = <span class="charliteral">'\0'</span>;
00577 
00578       <a class="code" href="util_8h.html#a10">xvprintf</a>(<span class="stringliteral">"Old buffer: (%s)\n"</span>, rr_data);
00579       <a class="code" href="util_8h.html#a10">xvprintf</a>(<span class="stringliteral">"New buffer: (%s)\n"</span>, r_buf);
00580 
00581       pos = NULL;
00582     }
00583 
00584     <span class="comment">/* no valid SPFv1 record here */</span>
00585     <a class="code" href="util_8h.html#a6">xfree</a>(rr_data);
00586 
00587     <span class="keywordflow">return</span>(r_buf);
00588   }
00589 
00590   <a class="code" href="util_8h.html#a11">xpprintf</a>(<span class="stringliteral">"Returning NULL (not a valid SPF TXT record)\n"</span>);
00591 
00592   <span class="keywordflow">return</span>(NULL);
00593 }
00594 
00595 
00596 <span class="comment">/* DNS_mx_answer</span>
00597 <span class="comment">*</span>
00598 <span class="comment">*  Author: James Couzens &lt;jcouzens@codeshare.ca&gt;</span>
00599 <span class="comment">*</span>
00600 <span class="comment">*  Date:   01/02/04</span>
00601 <span class="comment">*  Date:   02/20/04 - Added cache by Travis Anderson &lt;tanderson@codeshare.ca&gt;</span>
00602 <span class="comment">*</span>
00603 <span class="comment">*  Desc:</span>
00604 <span class="comment">*          SPF_PACKETSZ bytes are allocated and then filled with \0 chars.</span>
00605 <span class="comment">*  This buffer is then used in an MX DNS query using data from the passed</span>
00606 <span class="comment">*  peer_info_t structure.  Upon success this buffer is re-cast as a char *</span>
00607 <span class="comment">*  and then a pointer to this memory is returned.  Upon failure a NULL</span>
00608 <span class="comment">*  pointer is returned.</span>
00609 <span class="comment">*</span>
00610 <span class="comment">*/</span>
<a name="l00611"></a><a class="code" href="dns_8h.html#a10">00611</a> <span class="keywordtype">char</span> *<a class="code" href="dns_8h.html#a10">DNS_mx_answer</a>(int16_t ancount, <span class="keyword">const</span> u_char *msg_ptr,
00612   <span class="keyword">const</span> u_char *eom_ptr, u_char *rd_ptr, <span class="keywordtype">char</span> *buf, <span class="keywordtype">int</span> *ttl)
00613 {
00614   size_t buf_len;          <span class="comment">/* buffer length */</span>
00615 
00616   int16_t i;               <span class="comment">/* utility */</span>
00617   int16_t rc;              <span class="comment">/* generic return code / length of */</span>
00618   int16_t rd_pref;         <span class="comment">/* MX preference */</span>
00619   int16_t rd_type;         <span class="comment">/* answer type */</span>
00620   int16_t rd_len = 0;      <span class="comment">/* res_search return code &amp; packet len */</span>
00621 
00622   int32_t rd_ttl;          <span class="comment">/* TTL */</span>
00623 
00624   <span class="keywordtype">char</span> *rr_data = NULL;    <span class="comment">/* data pointer */</span>
00625 
00626 
00627   i = 0;
00628   <span class="keywordflow">while</span> ((ancount &gt; 0) &amp;&amp; (rd_ptr &lt; eom_ptr))
00629   {
00630     <span class="keywordflow">if</span> ((rc = dn_expand(msg_ptr, eom_ptr, rd_ptr, buf, <a class="code" href="dns_8h.html#a3">SPF_MAXCDNAME</a>)) &lt; 0)
00631     {
00632       <a class="code" href="util_8h.html#a10">xvprintf</a>(<span class="stringliteral">"Error expanding ANSWER packet at count %i; Reason: %s \n"</span>,
00633         ancount, hstrerror(<a class="code" href="dns_8h.html#a6">h_errno</a>));
00634 
00635       <span class="keywordflow">return</span>(NULL);
00636     }
00637 
00638     <span class="comment">/* dname, type, class, TTL, rdata len, rdata */</span>
00639     rd_ptr += rc;                 <span class="comment">/* jump to start of ANSWER data */</span>
00640     GETSHORT(rd_type, rd_ptr);    <span class="comment">/* get response type */</span>
00641     rd_ptr += INT16SZ;            <span class="comment">/* skip class */</span>
00642     GETLONG(rd_ttl, rd_ptr);      <span class="comment">/* get TTL */</span>
00643     GETSHORT(rd_len, rd_ptr);     <span class="comment">/* get data length */</span>
00644 
00645     *ttl = rd_ttl;
00646 
00647     <span class="keywordflow">if</span> (rd_type != T_MX)
00648     {
00649       <a class="code" href="util_8h.html#a9">xprintf</a>(<span class="stringliteral">"Forged packet?!  We requested T_MX (15) but got %i\n"</span>, rd_type);
00650       rd_ptr += rd_len;
00651       <span class="keywordflow">continue</span>;
00652     }
00653 
00654     GETSHORT(rd_pref, rd_ptr);  <span class="comment">/* get MX preference */</span>
00655 
00656     <span class="keywordflow">if</span> ((rc = dn_expand(msg_ptr, eom_ptr, rd_ptr, buf, <a class="code" href="dns_8h.html#a3">SPF_MAXCDNAME</a>)) &lt; 0)
00657     {
00658       <a class="code" href="util_8h.html#a10">xvprintf</a>(<span class="stringliteral">"Error expanding ANSWER packet at count %i; Reason: %s \n"</span>,
00659         ancount, hstrerror(<a class="code" href="dns_8h.html#a6">h_errno</a>));
00660 
00661       <span class="keywordflow">return</span>(NULL);
00662     }
00663 
00664     <a class="code" href="util_8h.html#a10">xvprintf</a>(<span class="stringliteral">"MX: %s Preference: %i\n"</span>, buf, rd_pref);
00665 
00666     buf_len = strlen(buf);
00667     i += (buf_len + 1);
00668 
00669     <span class="keywordflow">if</span> ((rd_len &lt;= SPF_MAXDNAME) &amp;&amp; (rd_len &gt; 0))
00670     {
00671       <span class="keywordflow">if</span> (rr_data == NULL)
00672       {
00673         rr_data = <a class="code" href="util_8h.html#a4">xmalloc</a>(i + 1);
00674         <span class="comment">/*memset(rr_data, '\0', (i + 1));*/</span>
00675       }
00676       <span class="keywordflow">else</span>
00677       {
00678         rr_data = <a class="code" href="util_8h.html#a5">xrealloc</a>(rr_data, (i + 1));
00679       }
00680 
00681       <a class="code" href="util_8h.html#a10">xvprintf</a>(<span class="stringliteral">"REALLOCATE memory: %i bytes\n"</span>, (i + 1));
00682 
00683       strncat(rr_data, buf, buf_len);
00684       rr_data[i - 1] = <span class="charliteral">' '</span>;
00685       rr_data[i] = <span class="charliteral">'\0'</span>;
00686     }
00687 
00688     rd_ptr += rc;
00689     ancount--;
00690   }
00691 
00692   <span class="keywordflow">if</span> (rr_data != NULL)
00693   {
00694     rr_data[i - 1] = <span class="charliteral">'\0'</span>;
00695   }
00696 
00697   <span class="keywordflow">return</span>(rr_data);
00698 }
00699 
00700 
00701 <span class="comment">/* DNS_ptr_answer</span>
00702 <span class="comment">*</span>
00703 <span class="comment">*  Author: James Couzens &lt;jcouzens@codeshare.ca&gt;</span>
00704 <span class="comment">*</span>
00705 <span class="comment">*  Date:   01/02/04</span>
00706 <span class="comment">*  Date:   02/20/04 - Added cache by Travis Anderson &lt;tanderson@codeshare.ca&gt;</span>
00707 <span class="comment">*</span>
00708 <span class="comment">*  Desc:</span>
00709 <span class="comment">*          A reverse lookup on an IP address leads to a lookup per returned</span>
00710 <span class="comment">*  PTR answer to see if the returned answer matches.  The forward lookups are</span>
00711 <span class="comment">*  handled by a separate function which calls gethostbyname.  Upon a single</span>
00712 <span class="comment">*  successful match of a forward lookup with a reverse lookup, returns SPF_TRUE.</span>
00713 <span class="comment">*  Returns SPF_FALSE upon failure.</span>
00714 <span class="comment">*</span>
00715 <span class="comment">*/</span>
<a name="l00716"></a><a class="code" href="dns_8h.html#a11">00716</a> <a class="code" href="spf_8h.html#a35">SPF_BOOL</a> <a class="code" href="dns_8h.html#a11">DNS_ptr_answer</a>(<a class="code" href="structpeer__info__s.html">peer_info_t</a> *p, int16_t ancount,
00717 <span class="keyword">const</span> u_char *msg_ptr, <span class="keyword">const</span> u_char *eom_ptr, u_char *rd_ptr, <span class="keywordtype">char</span> *buf,
00718   <span class="keyword">const</span> <span class="keywordtype">char</span> *mta, <span class="keywordtype">int</span> *ttl)
00719 {
00720   int16_t rc;               <span class="comment">/* generic return code / length of */</span>
00721   int16_t rd_type;          <span class="comment">/* answer type */</span>
00722   int16_t rd_len = 0;       <span class="comment">/* res_search return code &amp; packet len */</span>
00723 
00724   int32_t rd_ttl;           <span class="comment">/* TTL */</span>
00725 
00726   <span class="keywordtype">char</span> *buf_cmp  = NULL;    <span class="comment">/* stores domain from buf's (ptr res) hostname */</span>
00727   <span class="keywordtype">char</span> *mta_cmp  = NULL;    <span class="comment">/* stores domain from rpeer's hostname */</span>
00728 
00729 
00730   <span class="keywordflow">while</span> ((ancount &gt; 0) &amp;&amp; (rd_ptr &lt; eom_ptr))
00731   {
00732     <span class="keywordflow">if</span> ((rc = dn_expand(msg_ptr, eom_ptr, rd_ptr, buf, <a class="code" href="dns_8h.html#a3">SPF_MAXCDNAME</a>)) &lt; 0)
00733     {
00734       <a class="code" href="util_8h.html#a10">xvprintf</a>(<span class="stringliteral">"Error expanding ANSWER packet at count %i; Reason: %s \n"</span>,
00735         ancount, hstrerror(<a class="code" href="dns_8h.html#a6">h_errno</a>));
00736 
00737       <span class="keywordflow">return</span>(<a class="code" href="spf_8h.html#a87a49">SPF_FALSE</a>);
00738     }
00739 
00740     <span class="comment">/* dname, type, class, TTL, rdata len, rdata */</span>
00741     rd_ptr += rc;                 <span class="comment">/* jump to start of ANSWER data */</span>
00742     GETSHORT(rd_type, rd_ptr);    <span class="comment">/* get response type */</span>
00743     rd_ptr += INT16SZ;            <span class="comment">/* skip class */</span>
00744     GETLONG(rd_ttl, rd_ptr);      <span class="comment">/* get TTL */</span>
00745     GETSHORT(rd_len, rd_ptr);     <span class="comment">/* get data length */</span>
00746 
00747     *ttl = rd_ttl;
00748 
00749     <span class="keywordflow">if</span> (rd_type != T_PTR)
00750     {
00751       rc = dn_expand(msg_ptr, eom_ptr, rd_ptr, buf, <a class="code" href="dns_8h.html#a3">SPF_MAXCDNAME</a>);
00752 
00753       <a class="code" href="util_8h.html#a10">xvprintf</a>(<span class="stringliteral">"Error expanding ANSWER packet at count %i; Reason: %s \n"</span>,
00754         ancount, hstrerror(<a class="code" href="dns_8h.html#a6">h_errno</a>));
00755 
00756       <a class="code" href="util_8h.html#a10">xvprintf</a>(<span class="stringliteral">"Got answer to type %i (%s) when we asked for T_PTR (%i)\n"</span>,
00757         rd_type, buf, T_PTR);
00758 
00759       rd_ptr += rd_len;
00760       <span class="keywordflow">continue</span>;
00761     }
00762 
00763     <span class="keywordflow">if</span> ((rc = dn_expand(msg_ptr, eom_ptr, rd_ptr, buf, <a class="code" href="dns_8h.html#a3">SPF_MAXCDNAME</a>)) &lt; 0)
00764     {
00765       <a class="code" href="util_8h.html#a10">xvprintf</a>(<span class="stringliteral">"Error expanding ANSWER packet at count %i; Reason: %s \n"</span>,
00766         ancount, hstrerror(<a class="code" href="dns_8h.html#a6">h_errno</a>));
00767 
00768       <a class="code" href="util_8h.html#a10">xvprintf</a>(<span class="stringliteral">"Error expanding ANSWER packet at count %i. (%s)\n"</span>,
00769         ancount, buf);
00770 
00771       <span class="keywordflow">return</span>(<a class="code" href="spf_8h.html#a87a49">SPF_FALSE</a>);
00772     }
00773 
00774     <a class="code" href="util_8h.html#a10">xvprintf</a>(<span class="stringliteral">"Answer %i has length %i.\n"</span>, ancount, rd_len);
00775     <a class="code" href="util_8h.html#a10">xvprintf</a>(<span class="stringliteral">"Answer data (buffer): (%s); buffer length: %i\n"</span>,
00776       buf, strlen(buf));
00777 
00778     <span class="keywordflow">if</span> ((rd_len &lt;= SPF_MAXDNAME) &amp;&amp; (rd_len &gt; 0))
00779     {
00780       <span class="keywordflow">if</span> (<a class="code" href="util_8h.html#a54">UTIL_validate_hostname</a>(p, buf, 32) == <a class="code" href="spf_8h.html#a87a49">SPF_FALSE</a>)
00781       {
00782         <a class="code" href="util_8h.html#a10">xvprintf</a>(<span class="stringliteral">"Unable to validate hostname (%s) with (%s)\n"</span>,
00783           buf, mta);
00784 
00785         rd_ptr += rc;
00786         ancount--;
00787         <span class="keywordflow">continue</span>;
00788       }
00789 
00790       <span class="comment">/* buf MUST be a subdomain of mta */</span>
00791       <span class="keywordflow">if</span> (strlen(buf) &lt; strlen(mta))
00792       {
00793         <span class="comment">/* not a chance */</span>
00794         rd_ptr += rc;
00795         ancount--;
00796         <span class="keywordflow">continue</span>;
00797       }
00798       <span class="keywordflow">else</span> <span class="keywordflow">if</span> (strlen(buf) == strlen(mta))
00799       {
00800         <span class="keywordflow">if</span> (strcasecmp(buf, mta) == 0)
00801         {
00802           <span class="keywordflow">return</span> (<a class="code" href="spf_8h.html#a87a50">SPF_TRUE</a>);
00803         }
00804         <span class="keywordflow">else</span>
00805         {
00806           rd_ptr += rc;
00807           ancount--;
00808           <span class="keywordflow">continue</span>;
00809         }
00810       }
00811       <span class="keywordflow">else</span>
00812       {
00813         buf_cmp = &amp;(buf[strlen(buf) - 1]);
00814         mta_cmp = (<span class="keywordtype">char</span> *)&amp;(mta[strlen(mta) - 1]);
00815 
00816         <span class="keywordflow">while</span> (mta_cmp != mta - 1)
00817         {
00818           <span class="keywordflow">if</span> (*mta_cmp-- != *buf_cmp--)
00819           {
00820             rd_ptr += rc;
00821             ancount--;
00822             <span class="keywordflow">continue</span>;
00823           }
00824         }
00825 
00826         <span class="keywordflow">if</span> (*buf_cmp == <span class="charliteral">'.'</span>)
00827         {
00828           <span class="keywordflow">return</span> (<a class="code" href="spf_8h.html#a87a50">SPF_TRUE</a>);
00829         }
00830         <span class="keywordflow">else</span>
00831         {
00832           rd_ptr += rc;
00833           ancount--;
00834           <span class="keywordflow">continue</span>;
00835         }
00836       }
00837     }
00838     <span class="keywordflow">else</span>
00839     {
00840       <a class="code" href="util_8h.html#a13">xepprintf</a>(<span class="stringliteral">"Answer length is too long!\n"</span>);
00841     }
00842 
00843     rd_ptr += rc;
00844     ancount--;
00845   }
00846 
00847   <span class="keywordflow">return</span>(<a class="code" href="spf_8h.html#a87a49">SPF_FALSE</a>);
00848 }
00849 
00850 
00851 <span class="comment">/* DNS_cname_answer</span>
00852 <span class="comment">*</span>
00853 <span class="comment">*  Author: Teddy &lt;teddy@teddy.ch&gt;</span>
00854 <span class="comment">*</span>
00855 <span class="comment">*  Date:   29/04/04</span>
00856 <span class="comment">*  Date:   02/20/04 - Added cache by Travis Anderson &lt;tanderson@codeshare.ca&gt;</span>
00857 <span class="comment">*</span>
00858 <span class="comment">*  Desc:</span>
00859 <span class="comment">*          SPF_PACKETSZ bytes are allocated and then filled with \0 chars.</span>
00860 <span class="comment">*  This buffer is then used in a TXT DNS query using data from the passed</span>
00861 <span class="comment">*  peer_info_t structure.  Upon success this buffer is re-cast as a char *</span>
00862 <span class="comment">*  and then a pointer to this memory is returned.  Upon failure a NULL</span>
00863 <span class="comment">*  pointer is returned.</span>
00864 <span class="comment">*</span>
00865 <span class="comment">*/</span>
<a name="l00866"></a><a class="code" href="dns_8h.html#a12">00866</a> <span class="keywordtype">char</span> *<a class="code" href="dns_8h.html#a12">DNS_cname_answer</a>(int16_t ancount, <span class="keyword">const</span> u_char *msg_ptr,
00867   <span class="keyword">const</span> u_char *eom_ptr, u_char *rd_ptr, <span class="keywordtype">char</span> *buf, <span class="keywordtype">int</span> *ttl)
00868 {
00869   int16_t i;               <span class="comment">/* utility */</span>
00870   int16_t rc;              <span class="comment">/* generic return code / length of */</span>
00871   int16_t rd_type;         <span class="comment">/* answer type */</span>
00872   int16_t rd_len;          <span class="comment">/* res_search return code &amp; packet len */</span>
00873 
00874   int32_t rd_ttl;          <span class="comment">/* TTL */</span>
00875 
00876   size_t buf_len;          <span class="comment">/* buffer length */</span>
00877 
00878   <span class="keywordtype">char</span> *rr_data = NULL;    <span class="comment">/* data pointer */</span>
00879 
00880 
00881   <span class="keywordflow">if</span> ((msg_ptr == NULL) || (eom_ptr == NULL) ||
00882       (rd_ptr == NULL)  || (buf == NULL))
00883   {
00884     <a class="code" href="util_8h.html#a13">xepprintf</a>(<span class="stringliteral">"Called with NULL pointers\n"</span>);
00885 
00886     <span class="keywordflow">return</span>(NULL);
00887   }
00888 
00889   <a class="code" href="util_8h.html#a11">xpprintf</a>(<span class="stringliteral">"entering function\n"</span>);
00890 
00891   i = 0;
00892   <span class="keywordflow">while</span> ((ancount &gt; 0) &amp;&amp; (rd_ptr &lt; eom_ptr))
00893   {
00894     <span class="keywordflow">if</span> ((rc = dn_expand(msg_ptr, eom_ptr, rd_ptr, buf, <a class="code" href="dns_8h.html#a3">SPF_MAXCDNAME</a>)) &lt; 0)
00895     {
00896       <a class="code" href="util_8h.html#a10">xvprintf</a>(<span class="stringliteral">"Error expanding ANSWER packet at count %i; Reason: %s \n"</span>,
00897         ancount, hstrerror(<a class="code" href="dns_8h.html#a6">h_errno</a>));
00898 
00899       <span class="keywordflow">return</span>(NULL);
00900     }
00901 
00902     <span class="comment">/* dname, type, class, TTL, rdata len, rdata */</span>
00903     rd_ptr += rc;                 <span class="comment">/* jump to start of ANSWER data */</span>
00904     GETSHORT(rd_type, rd_ptr);    <span class="comment">/* get response type */</span>
00905     rd_ptr += INT16SZ;            <span class="comment">/* skip class */</span>
00906     GETLONG(rd_ttl, rd_ptr);      <span class="comment">/* get TTL */</span>
00907     GETSHORT(rd_len, rd_ptr);     <span class="comment">/* get data length */</span>
00908 
00909     *ttl = rd_ttl;
00910 
00911     <span class="keywordflow">if</span> (rd_type != T_CNAME)
00912     {
00913       <a class="code" href="util_8h.html#a10">xvprintf</a>(<span class="stringliteral">"Ignoring record not of T_CNAME type. (%i)\n"</span>, rd_type);
00914       rd_ptr += rd_len;
00915       <span class="keywordflow">continue</span>;
00916     }
00917 
00918     <span class="keywordflow">if</span> (dn_expand(msg_ptr, eom_ptr, rd_ptr, buf, <a class="code" href="dns_8h.html#a3">SPF_MAXCDNAME</a>) &lt; 0)
00919     {
00920       <a class="code" href="util_8h.html#a10">xvprintf</a>(<span class="stringliteral">"Error expanding ANSWER packet at count %i; Reason: %s \n"</span>,
00921         ancount, hstrerror(<a class="code" href="dns_8h.html#a6">h_errno</a>));
00922 
00923       <span class="keywordflow">return</span>(NULL);
00924     }
00925 
00926     buf_len = strlen(buf);
00927     i += (buf_len + 1);
00928 
00929     <span class="keywordflow">if</span> ((rd_len &lt;= SPF_MAXDNAME) &amp;&amp; (rd_len &gt; 0))
00930     {
00931       <span class="keywordflow">if</span> (rr_data == NULL)
00932       {
00933         rr_data = <a class="code" href="util_8h.html#a4">xmalloc</a>(i + 1);
00934         <span class="comment">/*memset(rr_data, '\0', (i + 1));*/</span>
00935       }
00936       <span class="keywordflow">else</span>
00937       {
00938         rr_data = <a class="code" href="util_8h.html#a5">xrealloc</a>(rr_data, (i + 1));
00939       }
00940 
00941       <a class="code" href="util_8h.html#a10">xvprintf</a>(<span class="stringliteral">"REALLOCATE memory: %i bytes\n"</span>, (i + 1));
00942 
00943       strncat(rr_data, buf, buf_len);
00944       rr_data[i - 1] = <span class="charliteral">' '</span>;
00945       rr_data[i] = <span class="charliteral">'\0'</span>;
00946     }
00947 
00948     rd_ptr += rc;
00949     ancount--;
00950   }
00951 
00952   <span class="keywordflow">if</span> (rr_data != NULL)
00953   {
00954     rr_data[i - 1] = <span class="charliteral">'\0'</span>;
00955   }
00956 
00957   <a class="code" href="util_8h.html#a11">xpprintf</a>(<span class="stringliteral">"leaving function\n"</span>);
00958   <span class="keywordflow">return</span>(rr_data);
00959 }
00960 
00961 
00962 <span class="comment">/* DNS_check_client_reverse</span>
00963 <span class="comment">*</span>
00964 <span class="comment">*  Author: Travis Anderson &lt;tanderson@codeshare.ca&gt;</span>
00965 <span class="comment">*          Adapted from DNS_query</span>
00966 <span class="comment">*</span>
00967 <span class="comment">*  Date:   08/??/04 </span>
00968 <span class="comment">*</span>
00969 <span class="comment">*  Desc:</span>
00970 <span class="comment">*          First get addr's reverse then for each hostname returned, </span>
00971 <span class="comment">*  resolve it and then see if it matches addr.  If a match is found return </span>
00972 <span class="comment">*  SPF_TRUE if not return SPF_FALSE.</span>
00973 <span class="comment">*</span>
00974 <span class="comment">*/</span>
<a name="l00975"></a><a class="code" href="dns_8h.html#a13">00975</a> <a class="code" href="spf_8h.html#a35">SPF_BOOL</a> <a class="code" href="dns_8h.html#a13">DNS_check_client_reverse</a>(<a class="code" href="structpeer__info__s.html">peer_info_t</a> *p)
00976 {
00977 
00978   HEADER  *hdr;                 <span class="comment">/* pointer to the header of the packet */</span>
00979 
00980   int8_t ancount;               <span class="comment">/* number of answers */</span>
00981 
00982   int16_t rd_type;              <span class="comment">/* answer type */</span>
00983   int16_t rd_len = 0;           <span class="comment">/* res_search return code &amp; packet len */</span>
00984   int16_t r_len;                <span class="comment">/* res_search return code &amp; packet len */</span>
00985   int16_t rc;                   <span class="comment">/* generic return code / length of */</span>
00986 
00987   <span class="keywordtype">char</span> buf[<a class="code" href="dns_8h.html#a2">SPF_MAXDNAME</a>];       <span class="comment">/* record extraction buffer */</span>
00988   <span class="keywordtype">char</span> answer[<a class="code" href="dns_8h.html#a1">SPF_PACKETSZ</a>];    <span class="comment">/* answer buffer */</span>
00989 
00990   <span class="keywordtype">char</span> *addr_arpa = NULL;       <span class="comment">/* reverse address in dot-quad notation */</span>
00991 
00992   u_char *msg_ptr;              <span class="comment">/* pointer to beginning of the message */</span>
00993   u_char *eom_ptr;              <span class="comment">/* pointer to the end of the message */</span>
00994   u_char *rd_ptr;               <span class="comment">/* pointer to uncompressed message */</span>
00995 
00996 
00997   <span class="keywordflow">if</span> (p == NULL)
00998   {
00999     <a class="code" href="util_8h.html#a13">xepprintf</a>(<span class="stringliteral">"Unable to continue, peer info struct is NULL!\n"</span>);
01000 
01001     <span class="keywordflow">return</span>(<a class="code" href="spf_8h.html#a87a49">SPF_FALSE</a>);
01002   }
01003 
01004   <a class="code" href="util_8h.html#a11">xpprintf</a>(<span class="stringliteral">"entering function\n"</span>);
01005 
01006   addr_arpa = <a class="code" href="util_8h.html#a50">UTIL_rev_addr</a>(p-&gt;<a class="code" href="structpeer__info__s.html#o17">r_ip</a>);
01007 
01008   r_len = res_search(addr_arpa, C_IN, T_PTR, (u_char *)answer,
01009     <a class="code" href="dns_8h.html#a1">SPF_PACKETSZ</a>);
01010 
01011   <a class="code" href="util_8h.html#a6">xfree</a>(addr_arpa);
01012 
01013   hdr     = (HEADER *)&amp;answer;
01014   ancount = ntohs(hdr-&gt;ancount);
01015 
01016   <a class="code" href="util_8h.html#a10">xvprintf</a>(<span class="stringliteral">"Received packet size of %i bytes which contains %i answers.\n"</span>,
01017     r_len, ancount);
01018   <a class="code" href="util_8h.html#a10">xvprintf</a>(<span class="stringliteral">"ANSWERS: %i\n"</span>,   ancount);
01019   <a class="code" href="util_8h.html#a10">xvprintf</a>(<span class="stringliteral">"QUESTIONS: %i\n"</span>, ntohs(hdr-&gt;qdcount));
01020 
01021   <span class="keywordflow">if</span> (ancount &gt; 0)
01022   {
01023     msg_ptr = (u_char *)&amp;answer;                 <span class="comment">/* point to start of message */</span>
01024     eom_ptr = ((u_char *)&amp;answer + r_len);       <span class="comment">/* point to end of message */</span>
01025     rd_ptr  = ((u_char *)&amp;answer + HFIXEDSZ);    <span class="comment">/* point to start of RDATA */</span>
01026 
01027     <span class="keywordflow">if</span> ((rc = dn_skipname(rd_ptr, eom_ptr)) &lt; 0)
01028     {
01029       <a class="code" href="util_8h.html#a13">xepprintf</a>(<span class="stringliteral">"Error obtaining QUESTION!\n"</span>);
01030 
01031       <span class="keywordflow">return</span>(<a class="code" href="spf_8h.html#a87a49">SPF_FALSE</a>);
01032     }
01033 
01034     rd_ptr += rc + QFIXEDSZ;    <span class="comment">/* jump to start of ANSWER */</span>
01035 
01036     <span class="keywordflow">while</span> ((ancount &gt; 0) &amp;&amp; (rd_ptr &lt; eom_ptr))
01037     {
01038       <span class="keywordflow">if</span> ((rc = dn_expand(msg_ptr, eom_ptr, rd_ptr, buf, <a class="code" href="dns_8h.html#a3">SPF_MAXCDNAME</a>)) &lt; 0)
01039       {
01040         <a class="code" href="util_8h.html#a12">xeprintf</a>(<span class="stringliteral">"Error expanding ANSWER packet at count %i. (%s)\n"</span>,
01041           ancount, buf);
01042 
01043         <span class="keywordflow">return</span>(<a class="code" href="spf_8h.html#a87a49">SPF_FALSE</a>);
01044       }
01045 
01046        <span class="comment">/* dname, type, class, TTL, rdata len, rdata */</span>
01047       rd_ptr += rc;                 <span class="comment">/* jump to start of ANSWER data */</span>
01048       GETSHORT(rd_type, rd_ptr);    <span class="comment">/* get response type */</span>
01049       rd_ptr += INT16SZ;            <span class="comment">/* skip class */</span>
01050       rd_ptr += INT32SZ;            <span class="comment">/* skip TTL */</span>
01051       GETSHORT(rd_len, rd_ptr);     <span class="comment">/* get data length */</span>
01052 
01053       <span class="keywordflow">if</span> (rd_type != T_PTR)
01054       {
01055         rc = dn_expand(msg_ptr, eom_ptr, rd_ptr, buf, <a class="code" href="dns_8h.html#a3">SPF_MAXCDNAME</a>);
01056 
01057         <a class="code" href="util_8h.html#a10">xvprintf</a>(<span class="stringliteral">"Got answer to type %i (%s) when we asked for T_PTR (%i)\n"</span>,
01058           rd_type, buf, T_PTR);
01059 
01060         rd_ptr += rd_len;
01061         <span class="keywordflow">continue</span>;
01062       }
01063 
01064       <span class="keywordflow">if</span> ((rc = dn_expand(msg_ptr, eom_ptr, rd_ptr, buf, <a class="code" href="dns_8h.html#a3">SPF_MAXCDNAME</a>)) &lt; 0)
01065       {
01066         <a class="code" href="util_8h.html#a10">xvprintf</a>(<span class="stringliteral">"Error expanding ANSWER packet at count %i. (%s)\n"</span>,
01067           ancount, buf);
01068 
01069         <span class="keywordflow">return</span>(<a class="code" href="spf_8h.html#a87a49">SPF_FALSE</a>);
01070       }
01071 
01072       <a class="code" href="util_8h.html#a10">xvprintf</a>(<span class="stringliteral">"Answer %i has length %i.\n"</span>, ancount, rd_len);
01073       <a class="code" href="util_8h.html#a10">xvprintf</a>(<span class="stringliteral">"Answer data (buffer): (%s); data length: %i\n"</span>,
01074         buf, strlen(buf));
01075 
01076       <span class="keywordflow">if</span> ((rd_len &lt;= SPF_MAXDNAME) &amp;&amp; (rd_len &gt; 0))
01077       {
01078         <span class="keywordflow">if</span> (<a class="code" href="util_8h.html#a54">UTIL_validate_hostname</a>(p, buf, 32) == <a class="code" href="spf_8h.html#a87a49">SPF_FALSE</a>)
01079         {
01080           <a class="code" href="util_8h.html#a10">xvprintf</a>(<span class="stringliteral">"Unable to validate hostname (%s) with (%s)\n"</span>,
01081             buf, p-&gt;<a class="code" href="structpeer__info__s.html#o17">r_ip</a>);
01082 
01083           rd_ptr += rc;
01084           ancount--;
01085           <span class="keywordflow">continue</span>;
01086         }
01087         <span class="keywordflow">else</span>
01088         {
01089           <span class="keywordflow">if</span> (p-&gt;<a class="code" href="structpeer__info__s.html#o18">r_vhname</a> != NULL)
01090           {
01091             <a class="code" href="util_8h.html#a6">xfree</a>(p-&gt;<a class="code" href="structpeer__info__s.html#o18">r_vhname</a>);
01092           }
01093 
01094           p-&gt;<a class="code" href="structpeer__info__s.html#o18">r_vhname</a> = <a class="code" href="util_8h.html#a8">xstrndup</a>(buf, strlen(buf) + 1);
01095 
01096           <span class="keywordflow">return</span>(<a class="code" href="spf_8h.html#a87a50">SPF_TRUE</a>);
01097         } <span class="comment">/* if (UTIL_validate.. */</span>
01098       }
01099       <span class="keywordflow">else</span>
01100       {
01101         <a class="code" href="util_8h.html#a13">xepprintf</a>(<span class="stringliteral">"Answer length is too long!\n"</span>);
01102         <span class="keywordflow">continue</span>; 
01103       }
01104 
01105       rd_ptr += rc;
01106       ancount--;
01107 
01108     } <span class="comment">/* if (rd_len */</span>
01109   } <span class="comment">/* while (ancount */</span>
01110 
01111   <span class="keywordflow">return</span>(<a class="code" href="spf_8h.html#a87a49">SPF_FALSE</a>);
01112 }
01113 
01114 <span class="preprocessor">#ifdef _WITH_PTHREADS</span>
01115 <span class="preprocessor"></span><span class="preprocessor">  #ifdef HAVE_GETHOSTBYNAME_R</span>
01116 <span class="preprocessor"></span>
01117 <span class="comment">/* _DNS_gethostbyname_r</span>
01118 <span class="comment">*</span>
01119 <span class="comment">*  Author: James Couzens &lt;jcouzens@codeshare.ca&gt;</span>
01120 <span class="comment">*  Date:   08/28/04</span>
01121 <span class="comment">*</span>
01122 <span class="comment">*  Desc:</span>
01123 <span class="comment">*          A wrapper around the GNU gethostbyname_r extension function which</span>
01124 <span class="comment">*  introduces reentrant (some) resolver functionality allbeit way too bloody</span>
01125 <span class="comment">*  late.  Someone smack me with a tire iron and rewrite all of this using DJB.</span>
01126 <span class="comment">*</span>
01127 <span class="comment">*  This function is intented to be wrapped by a MACRO going by something along</span>
01128 <span class="comment">*  the lines of 'xgethostbyname' or 'xgethostbyname_r'.</span>
01129 <span class="comment">*</span>
01130 <span class="comment">*/</span>
01131 <span class="keyword">struct </span>hostent *_DNS_GNU_gethostbyname_r(<span class="keyword">const</span> <span class="keywordtype">char</span> *name,
01132   <span class="keyword">struct</span> hostent *result, <span class="keywordtype">char</span> *buf, <span class="keywordtype">int</span> buf_len, <span class="keywordtype">int</span> *h_errnop)
01133 {
01134   <span class="keyword">struct </span>hostent *hp = NULL;    <span class="comment">/* hostent structure */</span>
01135 
01136 
01137   <span class="keywordflow">if</span> (!name)
01138   {
01139     <a class="code" href="util_8h.html#a13">xepprintf</a>(<span class="stringliteral">"ERROR: No hostname to resolve.\n"</span>);
01140 
01141     <span class="keywordflow">return</span>(NULL);
01142   }
01143 
01144   <a class="code" href="util_8h.html#a11">xpprintf</a>(<span class="stringliteral">"entering function\n"</span>);
01145 
01146   <span class="keywordflow">if</span> (buf_len &gt;= <a class="code" href="spf_8h.html#a5">SPF_MAX_STR</a>)
01147   {
01148     <a class="code" href="util_8h.html#a10">xvprintf</a>(<span class="stringliteral">"buf_len (%i) is &gt; max size (%i); Disregarded.\n"</span>,
01149       buf_len, SPF_MAX_STR);
01150  
01151     <span class="keywordflow">return</span>(NULL);
01152   }
01153   
01154   <a class="code" href="util_8h.html#a10">xvprintf</a>(<span class="stringliteral">"called with hostname (%s)\n"</span>, name);
01155   memset(buf, <span class="charliteral">'\0'</span>, SPF_MAX_GHBNR_DBUF);
01156   hp = <a class="code" href="util_8h.html#a4">xmalloc</a>(<a class="code" href="util_8h.html#a3">SIZEOF</a>(<span class="keyword">struct</span> hostent));
01157 
01158   gethostbyname_r(name, result, buf, (size_t)buf_len, &amp;hp, h_errnop);
01159 
01160   <a class="code" href="util_8h.html#a11">xpprintf</a>(<span class="stringliteral">"leaving function\n"</span>);
01161 
01162   <span class="keywordflow">return</span>(hp);
01163 }
01164 
01165 <span class="preprocessor">  #else </span><span class="comment">/* HAVE_GETHOSTBYNAME_R */</span>
01166 
01167 <span class="comment">/* _DNS_gethostbyname_r</span>
01168 <span class="comment">*</span>
01169 <span class="comment">*  Author: James Couzens &lt;jcouzens@codeshare.ca&gt;</span>
01170 <span class="comment">*  Date:   08/28/04</span>
01171 <span class="comment">*</span>
01172 <span class="comment">*  Desc:</span>
01173 <span class="comment">*          Reentrant version of gethostbyname_r which is available as a</span>
01174 <span class="comment">*  GNU extension but unavailable to everyone else, so I've opted to</span>
01175 <span class="comment">*  implement it here.  This function is intented to be wrapped by a</span>
01176 <span class="comment">*  MACRO going by something along the lines of 'xgethostbyname' or</span>
01177 <span class="comment">*  'xgethostbyname_r'</span>
01178 <span class="comment">*</span>
01179 <span class="comment">*  Calling function is responsible to call _DNS_gethostbyname_r_free</span>
01180 <span class="comment">*  to unlock the mutex.</span>
01181 <span class="comment">*</span>
01182 <span class="comment">*/</span>
01183 <span class="keyword">struct </span>hostent *_DNS_gethostbyname_r(<span class="keyword">const</span> <span class="keywordtype">char</span> *name,
01184   <span class="keyword">struct</span> hostent *result, <span class="keywordtype">char</span> *buf, <span class="keywordtype">int</span> buf_len, <span class="keywordtype">int</span> *h_errnop)
01185 {
01186   <span class="keyword">struct </span>hostent *hp;    <span class="comment">/* hostent structure */</span>
01187 
01188   <span class="keywordflow">if</span> (!name)
01189   {
01190     <a class="code" href="util_8h.html#a13">xepprintf</a>(<span class="stringliteral">"ERROR: No hostname to resolve!\n"</span>);
01191     
01192     <span class="keywordflow">return</span>(NULL);
01193   }
01194 
01195   <a class="code" href="util_8h.html#a10">xvprintf</a>(<span class="stringliteral">"called with hostname (%s)\n"</span>, name);
01196 
01197   <a class="code" href="util_8h.html#a14">xpthread_mutex_lock</a>(&amp;dns_mutex);
01198 
01199   hp = gethostbyname(name);
01200   *h_errnop = <a class="code" href="dns_8h.html#a6">h_errno</a>;
01201 
01202   <a class="code" href="util_8h.html#a11">xpprintf</a>(<span class="stringliteral">"leaving function\n"</span>);
01203 
01204   <span class="keywordflow">return</span>(hp);
01205 }
01206 
01207 
01208 <span class="comment">/* _DNS_gethostbyname_r_free</span>
01209 <span class="comment">*</span>
01210 <span class="comment">*  Author: James Couzens &lt;jcouzens@codeshare.ca&gt;</span>
01211 <span class="comment">*  Date:   08/28/04</span>
01212 <span class="comment">*</span>
01213 <span class="comment">*  Desc:</span>
01214 <span class="comment">*          This function unlocks the mutex which was locked when</span>
01215 <span class="comment">*  _DNS_gethostbyname_r was called as a reentrant wrapper around the</span>
01216 <span class="comment">*  non-threadsafe 'gethostbyname' function call.  This function is</span>
01217 <span class="comment">*  intended to be wrapped by a MACRO going by something along the lines</span>
01218 <span class="comment">*  of 'xgethostbyname_free' or 'xgethostbyname_r_free'</span>
01219 <span class="comment">*</span>
01220 <span class="comment">*</span>
01221 <span class="comment">*/</span>
01222 <span class="keywordtype">void</span> <a class="code" href="dns_8h.html#a7">_DNS_gethostbyname_r_free</a>(<span class="keywordtype">void</span>)
01223 {
01224   <a class="code" href="util_8h.html#a15">xpthread_mutex_unlock</a>(&amp;dns_mutex);
01225 
01226   <span class="keywordflow">return</span>;
01227 }
01228 
01229 <span class="preprocessor">  #endif </span><span class="comment">/* HAVE_GETHOSTBYNAME_R */</span>
01230 <span class="preprocessor">#endif </span><span class="comment">/* _WITH_PTHREADS */</span>
01231 
01232 
01233 <span class="comment">/* end dns.c */</span>
</div></pre><hr size="1"><address style="align: right;"><small>Generated on Thu Sep 16 18:10:46 2004 for libSPF v1.0 by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 ></a> 1.3.8 </small></address>
</body>
</html>
