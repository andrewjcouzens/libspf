<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>libSPF v1.0: util.c Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.8 -->
<div class="qindex">  <form class="search" action="search.php" method="get">
<a class="qindex" href="main.html">Main&nbsp;Page</a> | <a class="qindex" href="annotated.html">Data&nbsp;Structures</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Data&nbsp;Fields</a> | <a class="qindex" href="globals.html">Globals</a>  | <span class="search"><u>S</u>earch&nbsp;for&nbsp;<input class="search" type="text" name="query" value="" size="20" accesskey="s"/></span></form></div>
<h1>util.c</h1><a href="util_8c.html">Go to the documentation of this file.</a><pre class="fragment"><div>00001 <span class="comment">/* libspf - Sender Policy Framework library</span>
00002 <span class="comment">*</span>
00003 <span class="comment">*  ANSI C implementation of spf-draft-200405.txt</span>
00004 <span class="comment">*</span>
00005 <span class="comment">*  Author: James Couzens &lt;jcouzens@codeshare.ca&gt;</span>
00006 <span class="comment">*  Author: Sean Comeau   &lt;scomeau@obscurity.org&gt;</span>
00007 <span class="comment">*</span>
00008 <span class="comment">*  File:   util.c</span>
00009 <span class="comment">*  Desc:   Utility functions</span>
00010 <span class="comment">*</span>
00011 <span class="comment">*  License:</span>
00012 <span class="comment">*</span>
00013 <span class="comment">*  The libspf Software License, Version 1.0</span>
00014 <span class="comment">*</span>
00015 <span class="comment">*  Copyright (c) 2004 James Couzens &amp; Sean Comeau  All rights</span>
00016 <span class="comment">*  reserved.</span>
00017 <span class="comment">*</span>
00018 <span class="comment">*  Redistribution and use in source and binary forms, with or without</span>
00019 <span class="comment">*  modification, are permitted provided that the following conditions</span>
00020 <span class="comment">*  are met:</span>
00021 <span class="comment">*</span>
00022 <span class="comment">*  1. Redistributions of source code must retain the above copyright</span>
00023 <span class="comment">*     notice, this list of conditions and the following disclaimer.</span>
00024 <span class="comment">*</span>
00025 <span class="comment">*  2. Redistributions in binary form must reproduce the above copyright</span>
00026 <span class="comment">*     notice, this list of conditions and the following disclaimer in</span>
00027 <span class="comment">*     the documentation and/or other materials provided with the</span>
00028 <span class="comment">*     distribution.</span>
00029 <span class="comment">*</span>
00030 <span class="comment">*  THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED</span>
00031 <span class="comment">*  WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES</span>
00032 <span class="comment">*  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE</span>
00033 <span class="comment">*  DISCLAIMED.  IN NO EVENT SHALL THE AUTHORS MAKING USE OF THIS LICESEN</span>
00034 <span class="comment">*  OR ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,</span>
00035 <span class="comment">*  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT</span>
00036 <span class="comment">*  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF</span>
00037 <span class="comment">*  USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND</span>
00038 <span class="comment">*  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,</span>
00039 <span class="comment">*  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT</span>
00040 <span class="comment">*  OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF</span>
00041 <span class="comment">*  SUCH DAMAGE.</span>
00042 <span class="comment">*</span>
00043 <span class="comment">*/</span>
00044 
00045 <span class="preprocessor">#ifdef _WITH_PTHREADS</span>
00046 <span class="preprocessor"></span><span class="preprocessor">#include &lt;pthread.h&gt;</span>          <span class="comment">/* pthread_mutex_t */</span>
00047 <span class="preprocessor">#endif </span><span class="comment">/* _WITH_PTHREADS */</span>
00048 
00049 <span class="preprocessor">#include "<a class="code" href="util_8h.html">util.h</a>"</span>             <span class="comment">/* Utility functions */</span>
00050 <span class="preprocessor">#include "<a class="code" href="dns_8h.html">dns.h</a>"</span>              <span class="comment">/* DNS Functions */</span>
00051 
00052 <span class="preprocessor">#undef  VERSION               </span><span class="comment">/* autoconf */</span>
00053 
00054 
00055 <span class="preprocessor">#ifdef _WITH_PTHREADS</span>
00056 <span class="preprocessor"></span> <span class="comment">/*</span>
00057 <span class="comment"> * pthread mutex used to facilitate reentrant competence within the</span>
00058 <span class="comment"> * utility functions (generally the debugging functionality, you</span>
00059 <span class="comment"> * could (after some poking around) probably safely remove this if</span>
00060 <span class="comment"> * debugging was disabled)</span>
00061 <span class="comment">*/</span>
00062 pthread_mutex_t <a class="code" href="util_8c.html#a0">util_mutex</a>;
00063 
00064 <span class="preprocessor">#else</span>
00065 <span class="preprocessor"></span><span class="comment">/* utility functions dummy pthread mutex wrapper */</span>
<a name="l00066"></a><a class="code" href="util_8h.html#a23">00066</a> <span class="keywordtype">void</span> *<a class="code" href="util_8c.html#a0">util_mutex</a>;
00067 
00068 <span class="preprocessor">#endif </span><span class="comment">/* _WITH_PTHREADS */</span>
00069 
00070 
00071 
00072  <span class="comment">/*</span>
00073 <span class="comment"> * globals</span>
00074 <span class="comment"> *</span>
00075 <span class="comment">*/</span>
00076 
00077 <span class="keyword">extern</span> <span class="keywordtype">int</span> <a class="code" href="util_8c.html#a1">errno</a>;
00078 
00079 
00080 
00081 <span class="comment">/* _pprintf_dbg</span>
00082 <span class="comment">*</span>
00083 <span class="comment">*  Author: James Couzens &lt;jcouzens@codeshare.ca&gt;</span>
00084 <span class="comment">*</span>
00085 <span class="comment">*  Date:   09/08/04</span>
00086 <span class="comment">*</span>
00087 <span class="comment">*  Desc:</span>
00088 <span class="comment">*          Handles debugging output when no variadic macro's are desired</span>
00089 <span class="comment">*  and the caller simply wishes to send a single string to output but</span>
00090 <span class="comment">*  wishes to have the appropriate function and other identifiers</span>
00091 <span class="comment">*  prepended.</span>
00092 <span class="comment">*</span>
00093 <span class="comment">*          Referenced by xpprintf (formerly used for profile output)</span>
00094 <span class="comment">*  and xepprintf.</span>
00095 <span class="comment">*</span>
00096 <span class="comment">*/</span>
<a name="l00097"></a><a class="code" href="util_8h.html#a25">00097</a> <span class="keywordtype">void</span> <a class="code" href="util_8h.html#a25">_pprintf_dbg</a>(u_int8_t level, <span class="keyword">const</span> <span class="keywordtype">char</span> *func, <span class="keyword">const</span> <span class="keywordtype">char</span> * file,
00098   <span class="keyword">const</span> size_t line, <span class="keyword">const</span> <span class="keywordtype">char</span> *s)
00099 {
00100   <span class="keywordtype">char</span> *buf;    <span class="comment">/* working buffer */</span>
00101 
00102 
00103   <span class="keywordflow">if</span> (!s)
00104   {
00105     fprintf(stderr, <span class="stringliteral">"_eprintf_dbg passed a NULL string\n"</span>);
00106     fflush(stderr);
00107 
00108     <span class="keywordflow">return</span>;
00109   }
00110 
00111   buf = <a class="code" href="util_8h.html#a4">xmalloc</a>(<a class="code" href="spf_8h.html#a3">SPF_MAX_DEBUG</a> + 1);
00112   snprintf(buf, <a class="code" href="spf_8h.html#a3">SPF_MAX_DEBUG</a>, <span class="stringliteral">"[%s :: %s-&gt;%i]; %s"</span>, func, file, line, s);
00113 
00114   <span class="keywordflow">if</span> (<a class="code" href="util_8h.html#a16">f_bit_set</a>(<a class="code" href="main_8c.html#a0">confg</a>.<a class="code" href="structspf__config__s.html#o0">level</a>, level))
00115   {
00116     <span class="keywordflow">if</span> (level == <a class="code" href="main_8h.html#a4">FL_D</a>)          <span class="comment">/* xpprintf */</span>
00117     {
00118       fprintf(stdout, buf);
00119       fflush(stdout);
00120     }
00121   }
00122 
00123   <span class="keywordflow">if</span> (level == <a class="code" href="main_8h.html#a6">FL_F</a>)           <span class="comment">/* xepprintf */</span>
00124   { 
00125     fprintf(stderr, buf);
00126     fflush(stderr);
00127   }
00128 
00129   <a class="code" href="util_8h.html#a6">xfree</a>(buf);  
00130 
00131   <span class="keywordflow">return</span>;
00132 }
00133 
00134 
00135 <span class="comment">/* _printf_dbg</span>
00136 <span class="comment">*</span>
00137 <span class="comment">*  Author: James Couzens &lt;jcouzens@codeshare.ca&gt;</span>
00138 <span class="comment">*</span>
00139 <span class="comment">*  Date:   12/25/03</span>
00140 <span class="comment">*  Date:   02/18/04 (updated)</span>
00141 <span class="comment">*</span>
00142 <span class="comment">*  Desc:</span>
00143 <span class="comment">*          Tied to a compile time switch this can instantly and at little</span>
00144 <span class="comment">*  to no real expense enable a discreet debugging with out hoards of</span>
00145 <span class="comment">*  #ifdefs all over the place.</span>
00146 <span class="comment">*</span>
00147 <span class="comment">*  Date:   09/08/04 - James Couzens &lt;jcouzens@codeshare.ca&gt;</span>
00148 <span class="comment">*</span>
00149 <span class="comment">*  Desc:</span>
00150 <span class="comment">*          Modified to handle output for xeprintf (behaviour adjusted to call</span>
00151 <span class="comment">*  here instead) so that its actually clear where errors are being raised from.</span>
00152 <span class="comment">*</span>
00153 <span class="comment">*/</span>
<a name="l00154"></a><a class="code" href="util_8h.html#a24">00154</a> <span class="keywordtype">void</span> <a class="code" href="util_8h.html#a24">_printf_dbg</a>(u_int8_t level, <span class="keyword">const</span> <span class="keywordtype">char</span> *func, <span class="keyword">const</span> <span class="keywordtype">char</span> *file,
00155   <span class="keyword">const</span> size_t line, <span class="keyword">const</span> <span class="keywordtype">char</span> *format,...)
00156 {
00157 <span class="preprocessor">#ifdef _SPF_DEBUG_LOGFILE</span>
00158 <span class="preprocessor"></span>  FILE     *fp      = NULL;    <span class="comment">/* file pointer */</span>
00159 <span class="preprocessor">#endif </span><span class="comment">/* _SPF_DEBUG_LOGFILE */</span>
00160 
00161   <span class="keywordtype">char</span> *buf;                   <span class="comment">/* working buffer */</span>
00162   <span class="keywordtype">char</span> *tbuf;                  <span class="comment">/* working buffer for eprintf */</span>
00163 
00164   va_list argptr;              <span class="comment">/* pointer to current argument from array */</span>
00165 
00166 
00167   <a class="code" href="util_8h.html#a14">xpthread_mutex_lock</a>(&amp;<a class="code" href="util_8c.html#a0">util_mutex</a>);
00168 
00169   <span class="keywordflow">if</span> (!format || *format == <span class="charliteral">'\0'</span>)
00170   {
00171     fprintf(stderr, <span class="stringliteral">"_printf_dbg passed null format array\n"</span>);
00172     fflush(stderr);
00173 
00174     <span class="keywordflow">return</span>;
00175   }
00176 
00177   buf  = <a class="code" href="util_8h.html#a4">xmalloc</a>(<a class="code" href="spf_8h.html#a3">SPF_MAX_DEBUG</a> + 1);
00178   tbuf = <a class="code" href="util_8h.html#a4">xmalloc</a>(<a class="code" href="spf_8h.html#a3">SPF_MAX_DEBUG</a> + 1);
00179 
00180   va_start(argptr, format);
00181   vsnprintf(buf, <a class="code" href="spf_8h.html#a3">SPF_MAX_DEBUG</a>, format, argptr);
00182   va_end(argptr);
00183 
00184   snprintf(tbuf, <a class="code" href="spf_8h.html#a3">SPF_MAX_DEBUG</a>, <span class="stringliteral">"[%s :: %s-&gt;%i]; %s"</span>, func, file, line, buf);
00185 
00186   <span class="comment">/* xepprintf */</span>
00187   <span class="keywordflow">if</span> (level == <a class="code" href="main_8h.html#a5">FL_E</a>)
00188   {
00189     fprintf(stderr, tbuf);
00190     fflush(stderr);
00191   }
00192   <span class="keywordflow">else</span>
00193   {
00194     <span class="keywordflow">if</span> (<a class="code" href="util_8h.html#a16">f_bit_set</a>(<a class="code" href="main_8c.html#a0">confg</a>.<a class="code" href="structspf__config__s.html#o0">level</a>, level))
00195     {
00196 <span class="preprocessor">#ifndef _SPF_DEBUG_LOGFILE</span>
00197 <span class="preprocessor"></span>      fprintf(stdout, tbuf);
00198       fflush(stdout);
00199 <span class="preprocessor">#else</span>
00200 <span class="preprocessor"></span>      <span class="keywordflow">if</span> ((fp = fopen(<a class="code" href="util_8h.html#a18">DEBUG_LOG_FILE</a>, <span class="stringliteral">"a"</span>)) != NULL)
00201       {
00202         fprintf(fp, <span class="stringliteral">"[%s :: %s-&gt;%i]; %s"</span>, func, file, line, buf);
00203         fclose(fp);
00204       }
00205       <span class="keywordflow">else</span>
00206       {
00207         fprintf(stderr, <span class="stringliteral">"libSPF can't open file (%s) for writing!\n"</span>,
00208           <a class="code" href="util_8h.html#a18">DEBUG_LOG_FILE</a>);
00209         fflush(stderr);
00210         perror(func);
00211       }
00212 <span class="preprocessor">#endif </span><span class="comment">/* _SPF_DEBUG_LOGFILE */</span>
00213     }
00214   } <span class="comment">/* else */</span>
00215 
00216   free(buf);
00217   free(tbuf);
00218 
00219   <a class="code" href="util_8h.html#a15">xpthread_mutex_unlock</a>(&amp;<a class="code" href="util_8c.html#a0">util_mutex</a>);
00220 
00221   <span class="keywordflow">return</span>;
00222 }
00223 
00224 
00225 <span class="preprocessor">#ifndef _SPF_DEBUG_LOGFILE</span>
00226 <span class="preprocessor"></span><span class="comment">/* dummy_debug</span>
00227 <span class="comment">*</span>
00228 <span class="comment">*  Author: James Couzens &lt;jcouzens@codeshare.ca&gt;</span>
00229 <span class="comment">*</span>
00230 <span class="comment">*  Date:   12/25/03</span>
00231 <span class="comment">*</span>
00232 <span class="comment">*  Desc:</span>
00233 <span class="comment">*          dummy function thats used instead of the _printf_dbg function</span>
00234 <span class="comment">*  when compiling without debugging</span>
00235 <span class="comment">*</span>
00236 <span class="comment">*/</span>
<a name="l00237"></a><a class="code" href="util_8h.html#a26">00237</a> <span class="keywordtype">void</span> <a class="code" href="util_8h.html#a26">_dummy_debug</a>(<span class="keyword">const</span> u_int8_t level, <span class="keyword">const</span> <span class="keywordtype">char</span> *func, <span class="keyword">const</span> <span class="keywordtype">char</span> *file,
00238   <span class="keyword">const</span> size_t line, <span class="keyword">const</span> <span class="keywordtype">char</span> *format,...)
00239 {
00240   <span class="keywordflow">return</span>;
00241 }
00242 
00243 
00244 <span class="comment">/* dummy_debug</span>
00245 <span class="comment">*</span>
00246 <span class="comment">*  Author: James Couzens &lt;jcouzens@codeshare.ca&gt;</span>
00247 <span class="comment">*     </span>
00248 <span class="comment">*  Date:   12/25/03</span>
00249 <span class="comment">*     </span>
00250 <span class="comment">*  Desc:</span>
00251 <span class="comment">*          dummy function thats used instead of the _printf_dbg function</span>
00252 <span class="comment">*  when compiling without debugging</span>
00253 <span class="comment">*       </span>
00254 <span class="comment">*/</span> 
<a name="l00255"></a><a class="code" href="util_8h.html#a27">00255</a> <span class="keywordtype">void</span> <a class="code" href="util_8h.html#a27">_dummy_pdebug</a>(<span class="keyword">const</span> u_int8_t level, <span class="keyword">const</span> <span class="keywordtype">char</span> *func, <span class="keyword">const</span> <span class="keywordtype">char</span> *file,
00256   <span class="keyword">const</span> size_t line, <span class="keyword">const</span> <span class="keywordtype">char</span> *s)
00257 {
00258   <span class="keywordflow">return</span>;
00259 }     
00260 
00261 <span class="preprocessor">#endif</span>
00262 <span class="preprocessor"></span>
00263 
00264 <span class="comment">/* UTIL_get_date</span>
00265 <span class="comment">*</span>
00266 <span class="comment">*  Author: James Couzens &lt;jcouzens@codeshare.ca&gt;</span>
00267 <span class="comment">*  Date:   Sun Jan 18 06:02:13 PST 2004</span>
00268 <span class="comment">*</span>
00269 <span class="comment">*  Desc:</span>
00270 <span class="comment">*          Returns in a buffer that must be freed by the caller, the date</span>
00271 <span class="comment">*  in the format YY-MM-DD HH:MM:SS and is derived from UTC time.</span>
00272 <span class="comment">*</span>
00273 <span class="comment">*  Date:   09/08/04 - James Couzens &lt;jcouzens@codeshare.ca&gt;</span>
00274 <span class="comment">*</span>
00275 <span class="comment">*  Desc:</span>
00276 <span class="comment">*          Added pthread mutex lock during body of this function because it</span>
00277 <span class="comment">*  appears as those inspite of the use of localtime_r there is some un-safe</span>
00278 <span class="comment">*  behaviour that goes on here so for now the mutex here appears to solve</span>
00279 <span class="comment">*  the problem.</span>
00280 <span class="comment">*</span>
00281 <span class="comment">*/</span>
<a name="l00282"></a><a class="code" href="util_8h.html#a32">00282</a> <span class="keywordtype">char</span> *<a class="code" href="util_8c.html#a6">UTIL_get_date</a>(<span class="keywordtype">void</span>)
00283 {
00284   <span class="keyword">struct </span>tm *now;     <span class="comment">/* time in tm struct format  */</span>
00285   <span class="keyword">struct </span>tm tmbuf;    <span class="comment">/* reentrant buffer for localtime_r */</span>
00286 
00287   time_t curtime;     <span class="comment">/* current time time_t struct format */</span>
00288 
00289   <span class="keywordtype">char</span> *my_time;      <span class="comment">/* time in human readable format */</span>
00290 
00291 
00292   <a class="code" href="util_8h.html#a14">xpthread_mutex_lock</a>(&amp;<a class="code" href="util_8c.html#a0">util_mutex</a>);
00293 
00294   curtime = time(NULL);
00295   now     = localtime_r(&amp;curtime, &amp;tmbuf);
00296   my_time = <a class="code" href="util_8h.html#a4">xmalloc</a>(<a class="code" href="util_8h.html#a1">SPF_MAX_DATETIME</a>);
00297 
00298   strftime(my_time, <a class="code" href="util_8h.html#a1">SPF_MAX_DATETIME</a>, <span class="stringliteral">"%Y-%m-%d %H:%M:%S "</span>, now);
00299   my_time[(<a class="code" href="util_8h.html#a1">SPF_MAX_DATETIME</a> - 1)] = <span class="charliteral">'\0'</span>;
00300 
00301   <a class="code" href="util_8h.html#a15">xpthread_mutex_unlock</a>(&amp;<a class="code" href="util_8c.html#a0">util_mutex</a>);
00302 
00303   <span class="keywordflow">return</span>(my_time);
00304 }
00305 
00306 
00307 <span class="comment">/* UTIL_log_result</span>
00308 <span class="comment">*</span>
00309 <span class="comment">*  Author: James Couzens &lt;jcouzens@codeshare.ca&gt;</span>
00310 <span class="comment">*</span>
00311 <span class="comment">*  Date:   02/04/04</span>
00312 <span class="comment">*</span>
00313 <span class="comment">*  Desc:</span>
00314 <span class="comment">*          Tied to a compile time switch this can instantly and at little</span>
00315 <span class="comment">*  to no real expense enable a discreet debugging with out hoards of</span>
00316 <span class="comment">*  #ifdefs all over the place.</span>
00317 <span class="comment">*</span>
00318 <span class="comment">*  Date:   09/08/04 - James Couzens &lt;jcouzens@codeshare.ca&gt;</span>
00319 <span class="comment">*</span>
00320 <span class="comment">*  Desc:</span>
00321 <span class="comment">*          Added pthread mutex lock during body of this function because it</span>
00322 <span class="comment">*  is to the detriment of stability to have multiple threads attempting to</span>
00323 <span class="comment">*  open/write/close the same file at the same time!  :-)</span>
00324 <span class="comment">*</span>
00325 <span class="comment">*/</span>
<a name="l00326"></a><a class="code" href="util_8h.html#a31">00326</a> <span class="keywordtype">void</span> <a class="code" href="util_8h.html#a31">UTIL_log_result</a>(<a class="code" href="structpeer__info__s.html">peer_info_t</a> *p)
00327 {
00328   FILE *fp = NULL;    <span class="comment">/* file pointer */</span>
00329 
00330   <span class="keywordtype">char</span> *buf;          <span class="comment">/* working buffer */</span>
00331   <span class="keywordtype">char</span> *date;         <span class="comment">/* date/time stamp */</span>
00332 
00333 
00334   date = <a class="code" href="util_8c.html#a6">UTIL_get_date</a>();
00335   buf  = <a class="code" href="util_8h.html#a4">xmalloc</a>(<a class="code" href="spf_8h.html#a3">SPF_MAX_DEBUG</a>);
00336   *(date + (strlen(date) - 1)) = <span class="charliteral">'\0'</span>;
00337 
00338   <span class="keywordflow">if</span> (p-&gt;<a class="code" href="structpeer__info__s.html#o5">spf_ver</a> == 0)
00339   {
00340     p-&gt;<a class="code" href="structpeer__info__s.html#o5">spf_ver</a> = <a class="code" href="spf_8h.html#a1">SPF_VERSION</a>;
00341   }
00342 
00343   <a class="code" href="util_8h.html#a14">xpthread_mutex_lock</a>(&amp;<a class="code" href="util_8c.html#a0">util_mutex</a>);
00344 
00345   snprintf(buf, <a class="code" href="spf_8h.html#a3">SPF_MAX_DEBUG</a>,
00346     <span class="stringliteral">"[%s] result: %s :: %s [%s], ver: %i, depth: %i, error: (%s)\n"</span>,
00347     date, p-&gt;<a class="code" href="structpeer__info__s.html#o25">spf_result</a>[p-&gt;<a class="code" href="structpeer__info__s.html#o1">RES</a>].s, p-&gt;<a class="code" href="structpeer__info__s.html#o10">from</a>,
00348     p-&gt;<a class="code" href="structpeer__info__s.html#o17">r_ip</a>, p-&gt;<a class="code" href="structpeer__info__s.html#o27">spf_rlevel</a>, p-&gt;<a class="code" href="structpeer__info__s.html#o5">spf_ver</a>, p-&gt;<a class="code" href="structpeer__info__s.html#o24">error</a>);
00349 
00350   <span class="keywordflow">if</span> ((fp = fopen(<a class="code" href="util_8h.html#a19">OUTPUT_LOG_FILE</a>, <span class="stringliteral">"a"</span>)) != NULL)
00351   {
00352     fprintf(fp, <span class="stringliteral">"%s"</span>, buf);
00353     fclose(fp);
00354   }
00355 
00356   <a class="code" href="util_8h.html#a15">xpthread_mutex_unlock</a>(&amp;<a class="code" href="util_8c.html#a0">util_mutex</a>);
00357 
00358   <a class="code" href="util_8h.html#a6">xfree</a>(date);
00359   <a class="code" href="util_8h.html#a6">xfree</a>(buf);
00360 
00361   <span class="keywordflow">return</span>;
00362 }
00363 
00364 
00365 <span class="comment">/* xstrndup</span>
00366 <span class="comment">*</span>
00367 <span class="comment">*  Author: James Couzens &lt;jcouzens@codeshare.ca&gt;</span>
00368 <span class="comment">*</span>
00369 <span class="comment">*  Date:   12/25/03</span>
00370 <span class="comment">*</span>
00371 <span class="comment">*  Desc:</span>
00372 <span class="comment">*          n bytes are allocated and then filled with \0 chars.  Char s</span>
00373 <span class="comment">*  is copied over to the allocated memory writing n -1 bytes leaving the</span>
00374 <span class="comment">*  new string NULL terminated.  This new string is returned upon success</span>
00375 <span class="comment">*  and NULL upon failure.</span>
00376 <span class="comment">*</span>
00377 <span class="comment">*/</span>
<a name="l00378"></a><a class="code" href="util_8h.html#a33">00378</a> <span class="keywordtype">char</span> *<a class="code" href="util_8h.html#a33">UTIL_strndup</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *s, <span class="keyword">const</span> size_t n)
00379 {
00380   <span class="keywordtype">char</span> *ret_ptr = NULL;    <span class="comment">/* return buffer */</span>
00381 
00382 
00383   <span class="keywordflow">if</span> ((s == NULL) || (n &lt;= 0))
00384   {
00385     <a class="code" href="util_8h.html#a13">xepprintf</a>(<span class="stringliteral">"Passed string is NULL.  Abort!.\n"</span>);
00386 
00387     <span class="keywordflow">return</span>(<a class="code" href="spf_8h.html#a87a49">SPF_FALSE</a>);
00388   }
00389 
00390   ret_ptr = <a class="code" href="util_8h.html#a4">xmalloc</a>(n + 1);
00391   <a class="code" href="util_8h.html#a10">xvprintf</a>(<span class="stringliteral">"Allocated %u bytes of memory.\n"</span>, n);
00392   snprintf(ret_ptr, n, s);
00393   <a class="code" href="util_8h.html#a10">xvprintf</a>(<span class="stringliteral">"leaving function; returning string: (%s)\n"</span>, ret_ptr);
00394 
00395   <span class="keywordflow">return</span>(ret_ptr);
00396 }
00397 
00398 
00399 <span class="comment">/* xstrdup</span>
00400 <span class="comment">*</span>
00401 <span class="comment">*  Author: Patrick Earl (http://patearl.net/)</span>
00402 <span class="comment">*          Adapted from xstrndup()</span>
00403 <span class="comment">*</span>
00404 <span class="comment">*  Date:   02/04/04</span>
00405 <span class="comment">*</span>
00406 <span class="comment">*  Desc:</span>
00407 <span class="comment">*          strlen(s)+1 bytes are allocated and s is copied into the</span>
00408 <span class="comment">* freshly allocated memory.  If the allocation or copy fails, NULL</span>
00409 <span class="comment">* NULL will be returned.</span>
00410 <span class="comment">*</span>
00411 <span class="comment">*/</span>
<a name="l00412"></a><a class="code" href="util_8h.html#a34">00412</a> <span class="keywordtype">char</span> *<a class="code" href="util_8h.html#a34">UTIL_strdup</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *s)
00413 {
00414   <span class="keywordtype">char</span> *ret_ptr = NULL;    <span class="comment">/* return buffer */</span>
00415 
00416 
00417   <span class="keywordflow">if</span> (s == NULL)
00418   {
00419     <a class="code" href="util_8h.html#a13">xepprintf</a>(<span class="stringliteral">"Passed string is NULL.  Abort!.\n"</span>);
00420 
00421     <span class="keywordflow">return</span>(<a class="code" href="spf_8h.html#a87a49">SPF_FALSE</a>);
00422   }
00423 
00424   <span class="keywordflow">if</span> ((ret_ptr = strdup(s)) == NULL)
00425   {
00426     <a class="code" href="util_8h.html#a13">xepprintf</a>(<span class="stringliteral">"Unable to allocate memory\n"</span>);
00427   }
00428 
00429   <a class="code" href="util_8h.html#a10">xvprintf</a>(<span class="stringliteral">"leaving function; returning string: (%s)\n"</span>, ret_ptr);
00430 
00431   <span class="keywordflow">return</span>(ret_ptr);
00432 }
00433 
00434 
00435 <span class="comment">/* UTIL_malloc</span>
00436 <span class="comment">*</span>
00437 <span class="comment">*  Author: Travis Anderson &lt;travis@anthrax.ca&gt;</span>
00438 <span class="comment">*  Author: James Couzens &lt;jcouzens@codeshare.ca&gt;</span>
00439 <span class="comment">*</span>
00440 <span class="comment">*  Date:   02/17/04</span>
00441 <span class="comment">*</span>
00442 <span class="comment">*  Desc:</span>
00443 <span class="comment">*         Wrapper for malloc.  Upon success, behaves as malloc does.</span>
00444 <span class="comment">*  Wrapper functionality is to print an error message and exit upon failure.</span>
00445 <span class="comment">*</span>
00446 <span class="comment">*/</span>
<a name="l00447"></a><a class="code" href="util_8h.html#a28">00447</a> <span class="keywordtype">void</span> *<a class="code" href="util_8h.html#a28">UTIL_malloc</a>(<span class="keyword">const</span> int32_t n, <span class="keyword">const</span> <span class="keywordtype">char</span> *file, int32_t line,
00448   <span class="keyword">const</span> <span class="keywordtype">char</span> *func)
00449 {
00450     <span class="keywordtype">void</span> *x = malloc(n);
00451 
00452     <span class="keywordflow">if</span> (x == NULL)
00453     {
00454         <a class="code" href="util_8h.html#a10">xvprintf</a>(<span class="stringliteral">"Unable to allocate %i bytes at %s:%i in %s\n"</span>,
00455           n, file, line, func);
00456 
00457          <span class="comment">/*</span>
00458 <span class="comment">         * Be advised this is the only place I do this, because quite</span>
00459 <span class="comment">         * honestly, if this library can't get a few bytes of memory,</span>
00460 <span class="comment">         * your mailserver segfaulting as a result of this exit, or </span>
00461 <span class="comment">         * quitting or whatever is the LEAST of your problems!</span>
00462 <span class="comment">        */</span>
00463         exit(0);
00464     }
00465 
00466     memset(x, <span class="charliteral">'\0'</span>, n);
00467 
00468     <span class="keywordflow">return</span>(x);
00469 }
00470 
00471 
00472 <span class="comment">/* UTIL_realloc</span>
00473 <span class="comment">*</span>
00474 <span class="comment">*  Author: Travis Anderson &lt;travis@anthrax.ca&gt;</span>
00475 <span class="comment">*  Author: James Couzens &lt;jcouzens@codeshare.ca&gt;</span>
00476 <span class="comment">*</span>
00477 <span class="comment">*  Date:   02/17/04</span>
00478 <span class="comment">*</span>
00479 <span class="comment">*  Desc:</span>
00480 <span class="comment">*         Wrapper for realloc.  If 'p' is NULL, allocates memory via a call to</span>
00481 <span class="comment">*  UTIL_malloc, otherwise if 'x' is assigned successfully, the behaviour is</span>
00482 <span class="comment">*  identical to realloc.  Wrapper functionality is to print an error message</span>
00483 <span class="comment">*  and exit upon failure.</span>
00484 <span class="comment">*</span>
00485 <span class="comment">*/</span>
<a name="l00486"></a><a class="code" href="util_8h.html#a29">00486</a> <span class="keywordtype">void</span> *<a class="code" href="util_8h.html#a29">UTIL_realloc</a>(<span class="keywordtype">void</span> *p, <span class="keyword">const</span> int32_t n, <span class="keyword">const</span> <span class="keywordtype">char</span> *file,
00487   <span class="keyword">const</span> int32_t line, <span class="keyword">const</span> <span class="keywordtype">char</span> *func)
00488 {
00489     <span class="keywordtype">void</span> *x = NULL;
00490 
00491     <span class="keywordflow">if</span> (p == NULL)
00492     {
00493       <span class="keywordflow">return</span>(<a class="code" href="util_8h.html#a28">UTIL_malloc</a>(n, file, line, func));
00494     }
00495 
00496     x = realloc(p, n);
00497     <span class="keywordflow">if</span> (x == NULL)
00498     {
00499         <a class="code" href="util_8h.html#a10">xvprintf</a>(<span class="stringliteral">"Unable to reallocate %i bytes at %s:%i in %s; "</span> \
00500           <span class="stringliteral">"original address 0x%x\n"</span>, n, file, line, func, (uintptr_t)p);
00501 
00502         exit(0);
00503     }
00504  
00505     <span class="keywordflow">return</span>(x);
00506 }
00507 
00508 
00509 <span class="comment">/* UTIL_free</span>
00510 <span class="comment">*</span>
00511 <span class="comment">*  Author: Travis Anderson &lt;travis@anthrax.ca&gt;</span>
00512 <span class="comment">*  Author: James Couzens &lt;jcouzens@codeshare.ca&gt;</span>
00513 <span class="comment">*</span>
00514 <span class="comment">*  Date:   02/17/04</span>
00515 <span class="comment">*</span>
00516 <span class="comment">*  Desc:</span>
00517 <span class="comment">*         Wrapper for free.  Upon success, behaves as free does.</span>
00518 <span class="comment">*  Wrapper functionality is to print an error message and exit upon</span>
00519 <span class="comment">*  failure.</span>
00520 <span class="comment">*</span>
00521 <span class="comment">*/</span>
<a name="l00522"></a><a class="code" href="util_8h.html#a30">00522</a> <span class="keywordtype">void</span> <a class="code" href="util_8h.html#a30">UTIL_free</a>(<span class="keywordtype">void</span> *p, <span class="keyword">const</span> <span class="keywordtype">char</span> *file, <span class="keyword">const</span> int32_t line, <span class="keyword">const</span> <span class="keywordtype">char</span> *func)
00523 {
00524     <span class="keywordflow">if</span> (p == NULL)
00525     {
00526         <a class="code" href="util_8h.html#a10">xvprintf</a>(<span class="stringliteral">"Unable to free() on NULL pointer at %s:%i in %s; "</span> \
00527           <span class="stringliteral">"address 0x%x.\n"</span>, file, line, func, (uintptr_t)p);
00528 
00529         <span class="keywordflow">return</span>;
00530     }
00531 
00532     <a class="code" href="util_8h.html#a10">xvprintf</a>(<span class="stringliteral">"Free address 0x%x by %s on line %i (%s)\n"</span>,
00533       (uintptr_t)p, func, line, file);
00534 
00535     free(p);
00536 
00537     <span class="keywordflow">return</span>;
00538 }
00539 
00540 
00541 <span class="comment">/* UTIL_index</span>
00542 <span class="comment">*</span>
00543 <span class="comment">*  Author:  James Couzens &lt;jcouzens@codeshare.ca&gt;</span>
00544 <span class="comment">*</span>
00545 <span class="comment">*  Date:   12/19/03</span>
00546 <span class="comment">*</span>
00547 <span class="comment">*  Desc:</span>
00548 <span class="comment">*          s is walked until c is found, at which time i is returned</span>
00549 <span class="comment">*  which is the number of bytes from the left it walked until c was</span>
00550 <span class="comment">*  found (not including c its self);</span>
00551 <span class="comment">*</span>
00552 <span class="comment">*  Date:   09/01/04 - Roger Moser</span>
00553 <span class="comment">*</span>
00554 <span class="comment">*  Desc:</span>
00555 <span class="comment">*          The return upon an error (s being NULL for exmaple) is now</span>
00556 <span class="comment">*  -1 because returning 0 was really ambiguous.</span>
00557 <span class="comment">*</span>
00558 <span class="comment">*  Returns: -1 upon error</span>
00559 <span class="comment">*  Returns: 0 upon no match</span>
00560 <span class="comment">*  Returns: &gt; 0 upon success which is the number of bytes from the left</span>
00561 <span class="comment">*           the string was walked until 'c' was found.</span>
00562 <span class="comment">*</span>
00563 <span class="comment">*/</span>
<a name="l00564"></a><a class="code" href="util_8h.html#a35">00564</a> int16_t <a class="code" href="util_8h.html#a35">UTIL_index</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *s, <span class="keyword">const</span> <span class="keywordtype">char</span> c)
00565 {
00566   int16_t i;     <span class="comment">/* utility */</span>
00567 
00568 
00569   <span class="keywordflow">if</span> (s == NULL)
00570   {
00571     <a class="code" href="util_8h.html#a13">xepprintf</a>(<span class="stringliteral">"passed a NULL string.  Abort!\n"</span>);
00572 
00573     <span class="keywordflow">return</span>(-1);
00574   }
00575 
00576   <a class="code" href="util_8h.html#a10">xvprintf</a>(<span class="stringliteral">"called with string: (%s); char: %c\n"</span>, s, c);
00577 
00578   i = 0;
00579   <span class="keywordflow">while</span> (*s)
00580   {
00581     <span class="keywordflow">if</span> (*s == c)
00582     {
00583       <a class="code" href="util_8h.html#a10">xvprintf</a>(<span class="stringliteral">"Found search char: (%c); Returning: (%i)\n"</span>, *s, i);
00584 
00585       <span class="keywordflow">return</span>(i);
00586     }
00587     i++;
00588     s++;
00589   }
00590 
00591   <a class="code" href="util_8h.html#a11">xpprintf</a>(<span class="stringliteral">"leaving function\n"</span>);
00592 
00593   <span class="keywordflow">return</span>(0);
00594 }
00595 
00596 
00597 <span class="comment">/* UTIL_split_str</span>
00598 <span class="comment">*</span>
00599 <span class="comment">*  Author:  James Couzens &lt;jcouzens@codeshare.ca&gt;</span>
00600 <span class="comment">*</span>
00601 <span class="comment">*  Date:   01/21/04</span>
00602 <span class="comment">*</span>
00603 <span class="comment">*  Desc:</span>
00604 <span class="comment">*          s is walked through to find 'delim' until it finds 'delim'</span>
00605 <span class="comment">*  num times.  Upon final match it returns the remainder of the string</span>
00606 <span class="comment">*  in a newly allocated buffer.  Upon failure returns NULL.</span>
00607 <span class="comment">*</span>
00608 <span class="comment">*  Date:   09/01/04 - Roger Moser</span>
00609 <span class="comment">* </span>
00610 <span class="comment">*  Desc:</span>
00611 <span class="comment">*          'cp' was not being freed upon exiting the function when 'c'</span>
00612 <span class="comment">*  was not found within the string.</span>
00613 <span class="comment">*</span>
00614 <span class="comment">*/</span>
<a name="l00615"></a><a class="code" href="util_8h.html#a36">00615</a> <span class="keywordtype">char</span> *<a class="code" href="util_8h.html#a36">UTIL_split_str</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *s, <span class="keyword">const</span> <span class="keywordtype">char</span> c, <span class="keyword">const</span> u_int8_t num)
00616 {
00617   u_int8_t i;    <span class="comment">/* utility */</span>
00618 
00619   <span class="keywordtype">char</span> *cp;      <span class="comment">/* copy buffer of s */</span>
00620   <span class="keywordtype">char</span> *p;       <span class="comment">/* pointer to copy */</span>
00621   <span class="keywordtype">char</span> *ret;     <span class="comment">/* return buffer */</span>
00622 
00623 
00624   <span class="keywordflow">if</span> (s == NULL)
00625   {
00626     <a class="code" href="util_8h.html#a13">xepprintf</a>(<span class="stringliteral">"passed a NULL string.  Abort!\n"</span>);
00627 
00628     <span class="keywordflow">return</span>(NULL);
00629   }
00630 
00631   <a class="code" href="util_8h.html#a10">xvprintf</a>(<span class="stringliteral">"called with string: (%s); char (%c); int: (%i)\n"</span>,
00632     s, c, num);
00633 
00634   p = cp = <a class="code" href="util_8h.html#a8">xstrndup</a>(s, <a class="code" href="spf_8h.html#a5">SPF_MAX_STR</a>);
00635 
00636   i = 0;
00637   <span class="keywordflow">while</span>(*p)
00638   {
00639     <span class="keywordflow">if</span> (*p == c)
00640     {
00641       i++;
00642       <span class="keywordflow">if</span> (i == num)
00643       {
00644         p++;
00645         ret = <a class="code" href="util_8h.html#a8">xstrndup</a>(p, <a class="code" href="spf_8h.html#a5">SPF_MAX_STR</a>);
00646 
00647         <a class="code" href="util_8h.html#a6">xfree</a>(cp);
00648 
00649         <a class="code" href="util_8h.html#a10">xvprintf</a>(<span class="stringliteral">"returning: %s\n"</span>, ret);
00650 
00651         <span class="keywordflow">return</span>(ret);
00652       }
00653     }
00654     p++;
00655   }
00656 
00657   <a class="code" href="util_8h.html#a6">xfree</a>(cp);
00658   <a class="code" href="util_8h.html#a10">xvprintf</a>(<span class="stringliteral">"[%i] returning NULL\n"</span>, i);
00659 
00660   <span class="keywordflow">return</span>(NULL);
00661 }
00662 
00663 
00664 <span class="comment">/* UTIL_split_strr</span>
00665 <span class="comment">*</span>
00666 <span class="comment">*  Author:  James Couzens &lt;jcouzens@codeshare.ca&gt;</span>
00667 <span class="comment">*</span>
00668 <span class="comment">*  Date:   01/30/04</span>
00669 <span class="comment">*</span>
00670 <span class="comment">*  Desc:</span>
00671 <span class="comment">*          s is walked to the end of its self, and then is walked back</span>
00672 <span class="comment">*  towards the beginning of the string until it has found 'c' the</span>
00673 <span class="comment">*  delimiter, 'num' times.  Upon success memory is allocated and the</span>
00674 <span class="comment">*  remainder of s is returned.  Upon failure NULL is returned.</span>
00675 <span class="comment">*</span>
00676 <span class="comment">*  Date:    09/01/04 - Roger Moser</span>
00677 <span class="comment">*</span>
00678 <span class="comment">*  Desc:</span>
00679 <span class="comment">*           Replaced 'p = (char *)&amp;(s[strlen(s) - 1]);' with a more</span>
00680 <span class="comment">*  optimized 'p = strchr(s, '\0') - 1;'.  Also applied a fix so that</span>
00681 <span class="comment">*  the function properly returns NULL when 's' is an empty string.</span>
00682 <span class="comment">*</span>
00683 <span class="comment">*/</span>
<a name="l00684"></a><a class="code" href="util_8h.html#a37">00684</a> <span class="keywordtype">char</span> *<a class="code" href="util_8h.html#a37">UTIL_split_strr</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *s, <span class="keyword">const</span> <span class="keywordtype">char</span> c, <span class="keyword">const</span> u_int8_t num)
00685 {
00686   u_int8_t i;    <span class="comment">/* number of times delim (c) is found */</span>
00687 
00688   <span class="keywordtype">char</span> *p;       <span class="comment">/* pointer to the last character of s before the \0 */</span>
00689   <span class="keywordtype">char</span> *ret;     <span class="comment">/* return buffer */</span>
00690 
00691 
00692   <span class="keywordflow">if</span> ((s == NULL) || (*s == <span class="charliteral">'\0'</span>))
00693   {
00694     <a class="code" href="util_8h.html#a13">xepprintf</a>(<span class="stringliteral">"passed a NULL string.  Abort!\n"</span>);
00695 
00696     <span class="keywordflow">return</span>(NULL);
00697   }
00698 
00699   <a class="code" href="util_8h.html#a10">xvprintf</a>(<span class="stringliteral">"called with (%s)\n"</span>, s);
00700 
00701 
00702   <span class="comment">/* assign 'p' to the last char before the null termination of 's'*/</span>
00703   <span class="comment">/*p = (char *)&amp;(s[strlen(s) - 1]);*/</span>
00704   p = (strchr(s, <span class="charliteral">'\0'</span>) - 1);
00705 
00706   i = 0;
00707   <span class="keywordflow">while</span>(p != s)
00708   {
00709     <span class="keywordflow">if</span> (*p == c)
00710     {
00711       i++;
00712       <span class="keywordflow">if</span> (i == num)
00713       {
00714         <span class="keywordflow">if</span> (*p == <span class="charliteral">'.'</span>)
00715         {
00716           p++; <span class="comment">/* don't want that period */</span>
00717         }
00718 
00719         ret = <a class="code" href="util_8h.html#a7">xstrdup</a>(p);
00720 
00721         <a class="code" href="util_8h.html#a10">xvprintf</a>(<span class="stringliteral">"delimiter found (%i) times; returning (%s).\n"</span>, i, ret);
00722 
00723         <span class="keywordflow">return</span>(ret);
00724       }
00725     }
00726     p--;
00727   }
00728 
00729   <a class="code" href="util_8h.html#a10">xvprintf</a>(<span class="stringliteral">"delimiter (%c) found (%u) times; returing NULL\n"</span>, c, i);
00730 
00731   <span class="keywordflow">return</span>(NULL);
00732 }
00733 
00734 
00735 <span class="comment">/* UTIL_count_delim</span>
00736 <span class="comment">*</span>
00737 <span class="comment">*  Author:  James Couzens &lt;jcouzens@codeshare.ca&gt;</span>
00738 <span class="comment">*</span>
00739 <span class="comment">*  Date:   01/21/04</span>
00740 <span class="comment">*</span>
00741 <span class="comment">*  Desc:</span>
00742 <span class="comment">*          s is walked through and each time 'delim' is found a counter is </span>
00743 <span class="comment">*  incremented and once complete, that integer is returned to the calling </span>
00744 <span class="comment">*  function.  Specifically for the purposes of this project i is limited by its</span>
00745 <span class="comment">*  type to 255.</span>
00746 <span class="comment">*</span>
00747 <span class="comment">*  Returns: &gt; 0 &amp;&amp; &lt;= 255 upon success</span>
00748 <span class="comment">*  Returns: 0 upon failure</span>
00749 <span class="comment">*</span>
00750 <span class="comment">*/</span>
<a name="l00751"></a><a class="code" href="util_8h.html#a38">00751</a> u_int8_t <a class="code" href="util_8h.html#a38">UTIL_count_delim</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *s, <span class="keyword">const</span> <span class="keywordtype">char</span> c)
00752 {
00753   u_int8_t i = 0;    <span class="comment">/* utility */</span>
00754 
00755 
00756   <span class="keywordflow">if</span> (s == NULL)
00757   {
00758     <a class="code" href="util_8h.html#a13">xepprintf</a>(<span class="stringliteral">"passed a NULL string.  Abort!\n"</span>);
00759 
00760     <span class="keywordflow">return</span>(0);
00761   }
00762 
00763   <span class="keywordflow">while</span> (*s &amp;&amp; i &lt; <a class="code" href="spf_8h.html#a6">SPF_MAX_DELIM</a>)
00764   {
00765     <span class="keywordflow">if</span> (*s == c)
00766     {
00767       i++;
00768     }
00769     s++;
00770   }
00771 
00772   <a class="code" href="util_8h.html#a10">xvprintf</a>(<span class="stringliteral">"found (%i) number of delimiters; returning.\n"</span>, i);
00773 
00774   <span class="keywordflow">return</span>(i);
00775 }
00776 
00777 
00778 <span class="comment">/* UTIL_is_spf_delim</span>
00779 <span class="comment">*</span>
00780 <span class="comment">*  Author:  James Couzens &lt;jcouzens@codeshare.ca&gt;</span>
00781 <span class="comment">*</span>
00782 <span class="comment">*  Date:   01/21/04</span>
00783 <span class="comment">*</span>
00784 <span class="comment">*  Desc:</span>
00785 <span class="comment">*          c is compared against all the valid spf delimiters and</span>
00786 <span class="comment">*  in the case of a SPF_PASS, the function returns true, otherwise it will</span>
00787 <span class="comment">*  return false.</span>
00788 <span class="comment">*</span>
00789 <span class="comment">*/</span>
<a name="l00790"></a><a class="code" href="util_8h.html#a39">00790</a> <a class="code" href="spf_8h.html#a35">SPF_BOOL</a> <a class="code" href="util_8h.html#a39">UTIL_is_spf_delim</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> c)
00791 {
00792 
00793   <span class="keywordflow">if</span> (!c)
00794   {
00795     <a class="code" href="util_8h.html#a13">xepprintf</a>(<span class="stringliteral">"called with a NULL char!  Aborting check.\n"</span>);
00796   
00797     <span class="keywordflow">return</span>(<a class="code" href="spf_8h.html#a87a49">SPF_FALSE</a>);
00798   }
00799 
00800   <a class="code" href="util_8h.html#a10">xvprintf</a>(<span class="stringliteral">"called with char (%c)\n"</span>, c);
00801 
00802   <span class="keywordflow">if</span> (c == <span class="charliteral">'.'</span> ||
00803       c == <span class="charliteral">'-'</span> ||
00804       c == <span class="charliteral">'+'</span> ||
00805       c == <span class="charliteral">','</span> ||
00806       c == <span class="charliteral">'|'</span> ||
00807       c == <span class="charliteral">'_'</span>)
00808   {
00809     <a class="code" href="util_8h.html#a11">xpprintf</a>(<span class="stringliteral">"leaving function; returning SPF_FALSE\n"</span>);
00810 
00811     <span class="keywordflow">return</span>(<a class="code" href="spf_8h.html#a87a50">SPF_TRUE</a>);
00812   }
00813 
00814   <a class="code" href="util_8h.html#a11">xpprintf</a>(<span class="stringliteral">"leaving function; returning SPF_FALSE\n"</span>);
00815 
00816   <span class="keywordflow">return</span>(<a class="code" href="spf_8h.html#a87a49">SPF_FALSE</a>);
00817 }
00818 
00819 
00820 <span class="comment">/* UTIL_is_spf_result</span>
00821 <span class="comment">*</span>
00822 <span class="comment">*  Author:  James Couzens &lt;jcouzens@codeshare.ca&gt;</span>
00823 <span class="comment">*</span>
00824 <span class="comment">*  Date:   01/27/04</span>
00825 <span class="comment">*</span>
00826 <span class="comment">*  Desc:</span>
00827 <span class="comment">*          c is compared against all the valid spf prefixes and</span>
00828 <span class="comment">*  in the case of a SPF_PASS, the function returns true, otherwise it will</span>
00829 <span class="comment">*  return false.</span>
00830 <span class="comment">*</span>
00831 <span class="comment">*/</span>
<a name="l00832"></a><a class="code" href="util_8h.html#a40">00832</a> <a class="code" href="spf_8h.html#a35">SPF_BOOL</a> <a class="code" href="util_8h.html#a40">UTIL_is_spf_result</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> c)
00833 {
00834   <span class="keywordflow">if</span> (!c)
00835   {
00836     <a class="code" href="util_8h.html#a11">xpprintf</a>(<span class="stringliteral">"passed a NULL or empty char!\n"</span>);
00837 
00838     <span class="keywordflow">return</span>(<a class="code" href="spf_8h.html#a87a49">SPF_FALSE</a>);
00839   }
00840 
00841   <a class="code" href="util_8h.html#a10">xvprintf</a>(<span class="stringliteral">"called with char (%c)\n"</span>, c);
00842 
00843   <span class="keywordflow">if</span> (c == <span class="charliteral">'+'</span> || c == <span class="charliteral">'-'</span> || c == <span class="charliteral">'~'</span> || c == <span class="charliteral">'?'</span>)
00844   {
00845     <a class="code" href="util_8h.html#a11">xpprintf</a>(<span class="stringliteral">"leaving function; returning SPF_TRUE\n"</span>);
00846 
00847     <span class="keywordflow">return</span>(<a class="code" href="spf_8h.html#a87a50">SPF_TRUE</a>);
00848   }
00849 
00850   <a class="code" href="util_8h.html#a11">xpprintf</a>(<span class="stringliteral">"leaving function; returning SPF_FALSE\n"</span>);
00851 
00852   <span class="keywordflow">return</span>(<a class="code" href="spf_8h.html#a87a49">SPF_FALSE</a>);
00853 }
00854 
00855 
00856 <span class="comment">/* UTIL_is_macro</span>
00857 <span class="comment">*</span>
00858 <span class="comment">*  Author:  James Couzens &lt;jcouzens@codeshare.ca&gt;</span>
00859 <span class="comment">*</span>
00860 <span class="comment">*  Date:   01/30/04</span>
00861 <span class="comment">*</span>
00862 <span class="comment">*  Desc:</span>
00863 <span class="comment">*          s is walked through in search of a macro which consist of</span>
00864 <span class="comment">*  %{?}, ? being an SPF_UNKNOWN number of chars in between.  An instance of</span>
00865 <span class="comment">*  a macro is searched for.  Upon success SPF_TRUE is returned.  Upon failure</span>
00866 <span class="comment">*  to find a macro, SPF_FALSE is returned.</span>
00867 <span class="comment">*</span>
00868 <span class="comment">*/</span>
<a name="l00869"></a><a class="code" href="util_8h.html#a41">00869</a> <a class="code" href="spf_8h.html#a35">SPF_BOOL</a> <a class="code" href="util_8h.html#a41">UTIL_is_macro</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *s)
00870 {
00871   <span class="keywordflow">if</span> (s == NULL)
00872   {
00873     <a class="code" href="util_8h.html#a13">xepprintf</a>(<span class="stringliteral">"passed a NULL string.  Abort!\n"</span>);
00874 
00875     <span class="keywordflow">return</span>(<a class="code" href="spf_8h.html#a87a49">SPF_FALSE</a>);
00876   }
00877 
00878   <a class="code" href="util_8h.html#a10">xvprintf</a>(<span class="stringliteral">"called with string (%s)\n"</span>, s);
00879 
00880   <span class="keywordflow">while</span> (*s++)
00881   {
00882     <span class="keywordflow">if</span> ((*s == <span class="charliteral">'%'</span>) &amp;&amp; (*(s + 1) == <span class="charliteral">'{'</span>))
00883     {
00884       <span class="keywordflow">if</span> (strstr(s, <span class="stringliteral">"}"</span>))
00885       {
00886         <a class="code" href="util_8h.html#a11">xpprintf</a>(<span class="stringliteral">"leaving function; returning SPF_TRUE\n"</span>);
00887 
00888         <span class="keywordflow">return</span>(<a class="code" href="spf_8h.html#a87a50">SPF_TRUE</a>);
00889       }
00890     }
00891   }
00892 
00893   <a class="code" href="util_8h.html#a11">xpprintf</a>(<span class="stringliteral">"leaving function; returning SPF_FALSE\n"</span>);
00894 
00895   <span class="keywordflow">return</span>(<a class="code" href="spf_8h.html#a87a49">SPF_FALSE</a>);
00896 }
00897 
00898 
00899 <span class="comment">/* UTIL_mx_cmp</span>
00900 <span class="comment">*</span>
00901 <span class="comment">*  Author: James Couzens &lt;jcouzens@codeshare.ca&gt;</span>
00902 <span class="comment">*</span>
00903 <span class="comment">*  Date:   01/02/04</span>
00904 <span class="comment">*</span>
00905 <span class="comment">*  Desc:</span>
00906 <span class="comment">*          Using the domain name found in the passed peer_info</span>
00907 <span class="comment">*  structure, the associated T_MX records are looked up and then their</span>
00908 <span class="comment">*  respective hostnames resolved (if they happen to be IP addresses the</span>
00909 <span class="comment">*  resolver library takes care of this. &lt;3).  Each IP is compared</span>
00910 <span class="comment">*  against the remote peer's IP (from peer_info).  Upon success returns</span>
00911 <span class="comment">*  SPF_TRUE, upon failure returns SPF_FALSE.</span>
00912 <span class="comment">*</span>
00913 <span class="comment">*/</span>
<a name="l00914"></a><a class="code" href="util_8h.html#a42">00914</a> <a class="code" href="spf_8h.html#a35">SPF_BOOL</a> <a class="code" href="util_8h.html#a42">UTIL_mx_cmp</a>(<a class="code" href="structpeer__info__s.html">peer_info_t</a> *p, <span class="keyword">const</span> <span class="keywordtype">char</span> *s, <span class="keyword">const</span> int8_t cidr)
00915 {
00916   <a class="code" href="spf_8h.html#a35">SPF_BOOL</a> MX_SPF_MATCH;    <span class="comment">/* true / false */</span>
00917 
00918   <span class="keywordtype">char</span> *rr_data = NULL;     <span class="comment">/* record */</span>
00919   <span class="keywordtype">char</span> *token;              <span class="comment">/* token for splitting records */</span>
00920   <span class="keywordtype">char</span> *token_ptr;          <span class="comment">/* working pointer when tokenizing */</span>
00921   <span class="keywordtype">char</span> *peer_ip;            <span class="comment">/* remote host converted to string */</span>
00922 
00923 
00924   MX_SPF_MATCH = <a class="code" href="spf_8h.html#a87a49">SPF_FALSE</a>;
00925   token_ptr    = rr_data;
00926 
00927   <span class="keywordflow">if</span> ((rr_data = <a class="code" href="dns_8h.html#a8">DNS_query</a>(p, s, T_MX, NULL)) == NULL)
00928   {
00929     <a class="code" href="util_8h.html#a11">xpprintf</a>(<span class="stringliteral">"SPF_ERROR parsing DNS Query\n"</span>);
00930 
00931     <span class="keywordflow">return</span>(<a class="code" href="spf_8h.html#a87a49">SPF_FALSE</a>);
00932   }
00933 
00934   <a class="code" href="util_8h.html#a10">xvprintf</a>(<span class="stringliteral">"rr_data is: (%s)\n"</span>, rr_data);
00935 
00936   peer_ip = <a class="code" href="util_8h.html#a8">xstrndup</a>(inet_ntoa(p-&gt;<a class="code" href="structpeer__info__s.html#o26">addr</a>), 16);
00937   token   = strtok_r(rr_data, <span class="stringliteral">" "</span>, &amp;token_ptr);
00938 
00939   <span class="keywordflow">while</span> (token != NULL)
00940   {
00941     <a class="code" href="util_8h.html#a10">xvprintf</a>(<span class="stringliteral">"TOKEN: (%s)\n"</span>, token);
00942 
00943     <span class="keywordflow">if</span> (<a class="code" href="util_8h.html#a54">UTIL_validate_hostname</a>(p, token, cidr) == <a class="code" href="spf_8h.html#a87a50">SPF_TRUE</a>)
00944     {
00945       <a class="code" href="util_8h.html#a10">xvprintf</a>(<span class="stringliteral">"%s validated via (%s)\n"</span>, p-&gt;<a class="code" href="structpeer__info__s.html#o10">from</a>, token);
00946 
00947       MX_SPF_MATCH = <a class="code" href="spf_8h.html#a87a50">SPF_TRUE</a>;
00948       <a class="code" href="util_8h.html#a47">UTIL_assoc_prefix</a>(p, <a class="code" href="spf_8h.html#a88a51">SPF_PASS</a>, NULL);
00949       token = NULL;
00950     }
00951     <span class="keywordflow">else</span>
00952     {
00953       token = strtok_r(NULL, <span class="stringliteral">" "</span>, &amp;token_ptr);
00954     }
00955   }
00956 
00957   <a class="code" href="util_8h.html#a6">xfree</a>(peer_ip);
00958   <a class="code" href="util_8h.html#a6">xfree</a>(rr_data);
00959 
00960   <span class="keywordflow">return</span>(MX_SPF_MATCH);
00961 }
00962 
00963 
00964 <span class="comment">/* UTIL_a_cmp</span>
00965 <span class="comment">*</span>
00966 <span class="comment">*  Author: James Couzens &lt;jcouzens@codeshare.ca&gt;</span>
00967 <span class="comment">*</span>
00968 <span class="comment">*  Date:   01/02/04</span>
00969 <span class="comment">*</span>
00970 <span class="comment">*  Desc:</span>
00971 <span class="comment">*          Calls gethostbyname to grab all records associated with a the</span>
00972 <span class="comment">*  hostname contained within s.  On success returns SPF_TRUE, on SPF_ERROR</span>
00973 <span class="comment">*  returns SPF_FALSE.</span>
00974 <span class="comment">*</span>
00975 <span class="comment">*  Note:</span>
00976 <span class="comment">*          We need to define and set a limit on the number of recursive</span>
00977 <span class="comment">*  lookups.  I recall seeing this in the RFC, we should discuss this.</span>
00978 <span class="comment">*</span>
00979 <span class="comment">*/</span>
<a name="l00980"></a><a class="code" href="util_8h.html#a43">00980</a> <a class="code" href="spf_8h.html#a35">SPF_BOOL</a> <a class="code" href="util_8h.html#a43">UTIL_a_cmp</a>(<a class="code" href="structpeer__info__s.html">peer_info_t</a> *p, <span class="keyword">const</span> <span class="keywordtype">char</span> *s, <span class="keyword">const</span> int8_t cidr)
00981 {
00982   int16_t pos;                      <span class="comment">/* position in DNS packet */</span>
00983 
00984   <span class="keywordtype">int</span> tmp_errno = 0;                <span class="comment">/* temporary errno placeholder */</span>
00985 
00986   size_t s_len;                     <span class="comment">/* length of s (hostname) */</span>
00987 
00988   <span class="keywordtype">char</span> *rr_data   = NULL;           <span class="comment">/* data storage for DNS query */</span>
00989   <span class="keywordtype">char</span> *token_ptr = NULL;           <span class="comment">/* token pointer */</span>
00990   <span class="keywordtype">char</span> *gbuf      = NULL;           <span class="comment">/* buf for reentrant gethostbyname call */</span>
00991   <span class="keywordtype">char</span> *copy      = NULL;           <span class="comment">/* copy of s */</span>
00992   <span class="keywordtype">char</span> *cp        = NULL;           <span class="comment">/* pointer to copy of s */</span>
00993 
00994   <span class="keywordtype">char</span> **a;                         
00995 
00996   <span class="keyword">struct </span>hostent *hp = NULL;        <span class="comment">/* hostent structure */</span>
00997   <span class="keyword">struct </span>hostent tmp_hp;            <span class="comment">/* temporary hostent (xgethostbyname) */</span>
00998 
00999   <a class="code" href="structpolicy__addr__s.html">policy_addr_t</a> policy_addr;        <span class="comment">/* used during CIDR comparisons */</span>
01000 
01001 
01002   <span class="keywordflow">if</span> (s == NULL)
01003   {
01004     <a class="code" href="util_8h.html#a13">xepprintf</a>(<span class="stringliteral">"Passed string is NULL.  Abort!.\n"</span>);
01005 
01006     <span class="keywordflow">return</span>(<a class="code" href="spf_8h.html#a87a49">SPF_FALSE</a>);
01007   }
01008 
01009   <a class="code" href="util_8h.html#a10">xvprintf</a>(<span class="stringliteral">"called with (%s) and cidr: %i\n"</span>, s, cidr);
01010 
01011   gbuf      = <a class="code" href="util_8h.html#a4">xmalloc</a>(<a class="code" href="util_8h.html#a2">SPF_MAX_GHBNR_DBUF</a>);
01012   s_len     = strlen(s);
01013   token_ptr = rr_data;
01014 
01015   <span class="comment">/* we're dealing with a:some.hostname/cidr */</span>
01016   <span class="keywordflow">if</span> ((s_len &gt; 1) &amp;&amp; (*(s + 1) == <span class="charliteral">':'</span>))
01017   {
01018     cp = copy = <a class="code" href="util_8h.html#a8">xstrndup</a>(s, (s_len + 1));
01019 
01020     <span class="keywordflow">if</span> (cidr != 32)
01021     {
01022       <span class="comment">/* We don't want a netmask, so lets remove it */</span>
01023       cp[s_len - 3] = <span class="charliteral">'\0'</span>;
01024     }
01025 
01026     <span class="keywordflow">if</span> ((pos = <a class="code" href="util_8h.html#a35">UTIL_index</a>(cp, <span class="charliteral">':'</span>)) &lt;= 0)
01027     {
01028       <a class="code" href="util_8h.html#a12">xeprintf</a>(<span class="stringliteral">"ERROR parsing passed mechanism token (%s)\n"</span>, cp);
01029 
01030       <a class="code" href="util_8h.html#a6">xfree</a>(copy);
01031       <a class="code" href="util_8h.html#a6">xfree</a>(gbuf);
01032 
01033       <span class="keywordflow">return</span>(<a class="code" href="spf_8h.html#a87a49">SPF_FALSE</a>);
01034     }
01035 
01036     <span class="comment">/* move passed the mechanism text */</span>
01037     cp += (pos + 1);
01038   }
01039   <span class="keywordflow">else</span>
01040   {
01041     cp = copy = <a class="code" href="util_8h.html#a8">xstrndup</a>(p-&gt;<a class="code" href="structpeer__info__s.html#o15">current_domain</a>, <a class="code" href="spf_8h.html#a14">SPF_MAX_HNAME</a>);
01042   }
01043 
01044   <span class="keywordflow">if</span> ((hp = <a class="code" href="dns_8h.html#a4">xgethostbyname</a>(cp, &amp;tmp_hp, gbuf, <a class="code" href="util_8h.html#a2">SPF_MAX_GHBNR_DBUF</a>,
01045     &amp;tmp_errno)) != NULL)
01046   {
01047     <span class="keywordflow">for</span> (a = hp-&gt;h_addr_list; *a; a++)
01048     {
01049       memcpy(&amp;policy_addr.addr.s_addr, *a, <a class="code" href="util_8h.html#a3">SIZEOF</a>(<span class="keyword">struct</span> in_addr));
01050 
01051       <a class="code" href="util_8h.html#a10">xvprintf</a>(<span class="stringliteral">"IN ADDR; Checking: %lu\n"</span>, policy_addr.addr.s_addr);
01052 
01053       <span class="comment">/* cidr is assumed checked by the calling function! */</span>
01054       policy_addr.cidr = cidr;
01055 
01056       <span class="keywordflow">if</span> (<a class="code" href="util_8h.html#a52">UTIL_cidr_cmp</a>(&amp;policy_addr, &amp;p-&gt;<a class="code" href="structpeer__info__s.html#o26">addr</a>) == <a class="code" href="spf_8h.html#a87a50">SPF_TRUE</a>)
01057       {
01058         *a = NULL;
01059 
01060         <a class="code" href="util_8h.html#a47">UTIL_assoc_prefix</a>(p, <a class="code" href="spf_8h.html#a88a51">SPF_PASS</a>, NULL);
01061 
01062         <a class="code" href="util_8h.html#a6">xfree</a>(copy);
01063         <a class="code" href="util_8h.html#a6">xfree</a>(gbuf);
01064 
01065         <a class="code" href="dns_8h.html#a5">xgethostbyname_free</a>();    <span class="comment">/* unlock mutex */</span>
01066 
01067         <span class="keywordflow">return</span>(<a class="code" href="spf_8h.html#a87a50">SPF_TRUE</a>);
01068       }
01069     } <span class="comment">/* for */</span>
01070  
01071     <span class="keywordflow">for</span> (a = hp-&gt;h_aliases; *a; a++)
01072     {
01073       memcpy(&amp;policy_addr.addr.s_addr, *a, <a class="code" href="util_8h.html#a3">SIZEOF</a>(<span class="keyword">struct</span> in_addr));
01074 
01075       <a class="code" href="util_8h.html#a10">xvprintf</a>(<span class="stringliteral">"IN CNAME; Checking: %lu\n"</span>, policy_addr.addr.s_addr);
01076 
01077       <span class="comment">/* cidr is assumed checked by the calling function! */</span>
01078       policy_addr.cidr = cidr;
01079 
01080       <span class="keywordflow">if</span> (<a class="code" href="util_8h.html#a52">UTIL_cidr_cmp</a>(&amp;policy_addr, &amp;p-&gt;<a class="code" href="structpeer__info__s.html#o26">addr</a>) == <a class="code" href="spf_8h.html#a87a50">SPF_TRUE</a>)
01081       {
01082         *a = NULL;
01083 
01084         <a class="code" href="util_8h.html#a47">UTIL_assoc_prefix</a>(p, <a class="code" href="spf_8h.html#a88a51">SPF_PASS</a>, NULL);
01085 
01086         <a class="code" href="util_8h.html#a6">xfree</a>(copy);
01087         <a class="code" href="util_8h.html#a6">xfree</a>(gbuf);
01088 
01089         <a class="code" href="dns_8h.html#a5">xgethostbyname_free</a>();    <span class="comment">/* unlock mutex */</span>
01090 
01091         <span class="keywordflow">return</span>(<a class="code" href="spf_8h.html#a87a50">SPF_TRUE</a>);
01092       }
01093     } <span class="comment">/* for */</span>
01094   } <span class="comment">/* if .. xgethostbyname */</span>
01095   <span class="keywordflow">else</span>
01096   {
01097     <a class="code" href="util_8h.html#a10">xvprintf</a>(<span class="stringliteral">"No address associated with hostname (%s); Reason: %s\n"</span>,
01098       s, hstrerror(tmp_errno));
01099   }
01100 
01101   <a class="code" href="util_8h.html#a6">xfree</a>(copy);
01102   <a class="code" href="util_8h.html#a6">xfree</a>(gbuf);
01103 
01104   <a class="code" href="dns_8h.html#a5">xgethostbyname_free</a>();
01105 
01106   <span class="keywordflow">return</span>(<a class="code" href="spf_8h.html#a87a49">SPF_FALSE</a>);
01107 }
01108 
01109 
01110 <span class="comment">/* UTIL_ptr_cmp</span>
01111 <span class="comment">*</span>
01112 <span class="comment">*  Author: James Couzens &lt;jcouzens@codeshare.ca&gt;</span>
01113 <span class="comment">*</span>
01114 <span class="comment">*  Date:   01/08/04</span>
01115 <span class="comment">*</span>
01116 <span class="comment">*  Desc:</span>
01117 <span class="comment">*          gethostbyaddr is broken in linux.  ?-&gt;h_aliases is not NULL,</span>
01118 <span class="comment">*  however, it doesn't contain any valid pointers either.  It grabs the</span>
01119 <span class="comment">*  first (and of course this is random) hostname it gets and thats all.</span>
01120 <span class="comment">*  As tested in FreeBSD however this call works.  At any rate, I've</span>
01121 <span class="comment">*  written a function to deal with this called DNS_ptr_answer.  From here</span>
01122 <span class="comment">*  that function is called which handles the reverse lookups and then</span>
01123 <span class="comment">*  attempts to "validate" each returned hostname by in turn looking it up</span>
01124 <span class="comment">*  to confirm if the ip address SPF_MATCHes.  Returns SPF_TRUE on succes, and SPF_FALSE</span>
01125 <span class="comment">*  on failure.</span>
01126 <span class="comment">*</span>
01127 <span class="comment">*  When passed SPF_TRUE copies into p-&gt;ptr_mhost, when SPF_FALSE copies</span>
01128 <span class="comment">*  into p-&gt;r_vhname</span>
01129 <span class="comment">*</span>
01130 <span class="comment">*  Note:</span>
01131 <span class="comment">*          We need to define and set a limit on the number of recursive</span>
01132 <span class="comment">*  lookups.  I recall seeing this in the RFC, we should discuss this.</span>
01133 <span class="comment">*</span>
01134 <span class="comment">*/</span>
<a name="l01135"></a><a class="code" href="util_8h.html#a44">01135</a> <a class="code" href="spf_8h.html#a35">SPF_BOOL</a> <a class="code" href="util_8h.html#a44">UTIL_ptr_cmp</a>(<a class="code" href="structpeer__info__s.html">peer_info_t</a> *p, <span class="keyword">const</span> <span class="keywordtype">char</span> *s)
01136 {
01137   <span class="keywordtype">char</span> *ptr_addr;    <span class="comment">/* reversed address into PTR format */</span>
01138   <span class="keywordtype">char</span> *tmp_ptr;     <span class="comment">/* utility pointer */</span>
01139 
01140 
01141   <span class="keywordflow">if</span> (s == NULL)
01142   {
01143     <a class="code" href="util_8h.html#a13">xepprintf</a>(<span class="stringliteral">"Passed string is NULL.  Abort!\n"</span>);
01144 
01145     <span class="keywordflow">return</span>(<a class="code" href="spf_8h.html#a87a49">SPF_FALSE</a>);
01146   }
01147 
01148   <a class="code" href="util_8h.html#a10">xvprintf</a>(<span class="stringliteral">"called with (%s)\n"</span>, s);
01149 
01150   <span class="comment">/* reverse of rpeer */</span>
01151   ptr_addr = <a class="code" href="util_8h.html#a50">UTIL_rev_addr</a>(p-&gt;<a class="code" href="structpeer__info__s.html#o17">r_ip</a>);
01152 
01153   <a class="code" href="util_8h.html#a10">xvprintf</a>(<span class="stringliteral">"address: %s\n"</span>, ptr_addr);
01154 
01155   <span class="keywordflow">if</span> ((s = strstr(s, <span class="stringliteral">":"</span>)) != NULL)
01156   {
01157     s++;
01158     tmp_ptr = <a class="code" href="util_8h.html#a8">xstrndup</a>(s, (strlen(s) + 1));
01159   }
01160   <span class="keywordflow">else</span>
01161   {
01162     tmp_ptr = <a class="code" href="util_8h.html#a8">xstrndup</a>(p-&gt;<a class="code" href="structpeer__info__s.html#o15">current_domain</a>, <a class="code" href="spf_8h.html#a14">SPF_MAX_HNAME</a>);
01163   }
01164 
01165   <span class="keywordflow">if</span> (<a class="code" href="dns_8h.html#a8">DNS_query</a>(p, ptr_addr, T_PTR, tmp_ptr) != (<span class="keywordtype">char</span> *)<a class="code" href="spf_8h.html#a87a50">SPF_TRUE</a>)
01166   {
01167     <a class="code" href="util_8h.html#a10">xvprintf</a>(<span class="stringliteral">"Failed to pass SPF PTR mechanism check:%s\n"</span>, <span class="stringliteral">""</span>);
01168     <a class="code" href="util_8h.html#a10">xvprintf</a>(<span class="stringliteral">"the domain pointed to by %s is not a valid subdomain of %s\n"</span>,
01169       ptr_addr, tmp_ptr);
01170 
01171     <a class="code" href="util_8h.html#a6">xfree</a>(ptr_addr);
01172     <a class="code" href="util_8h.html#a6">xfree</a>(tmp_ptr);
01173 
01174     <span class="keywordflow">return</span>(<a class="code" href="spf_8h.html#a87a49">SPF_FALSE</a>);
01175   }
01176 
01177   <a class="code" href="util_8h.html#a10">xvprintf</a>(<span class="stringliteral">"PTR lookup succeeded: (%s):(%s)\n"</span>, p-&gt;<a class="code" href="structpeer__info__s.html#o7">rs</a>,
01178     p-&gt;<a class="code" href="structpeer__info__s.html#o24">error</a>);
01179 
01180   <a class="code" href="util_8h.html#a6">xfree</a>(ptr_addr);
01181   <a class="code" href="util_8h.html#a6">xfree</a>(tmp_ptr);
01182 
01183   <span class="keywordflow">return</span>(<a class="code" href="spf_8h.html#a87a50">SPF_TRUE</a>);
01184 }
01185 
01186 
01187 <span class="comment">/* UTIL_get_policy_mech</span>
01188 <span class="comment">*</span>
01189 <span class="comment">*  Author: James Couzens &lt;jcouzens@codeshare.ca&gt;</span>
01190 <span class="comment">*</span>
01191 <span class="comment">*  Date:   12/19/03</span>
01192 <span class="comment">*</span>
01193 <span class="comment">*  Desc:</span>
01194 <span class="comment">*          Examins s and attempts to determine which SPF_MECHANISM</span>
01195 <span class="comment">*  enumeration the string SPF_MATCHes based on its conent.</span>
01196 <span class="comment">*</span>
01197 <span class="comment">*/</span>
<a name="l01198"></a><a class="code" href="util_8h.html#a45">01198</a> <a class="code" href="spf_8h.html#a38">SPF_MECHANISM</a> <a class="code" href="util_8h.html#a45">UTIL_get_policy_mech</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *s)
01199 {
01200   <span class="keywordflow">if</span> (s == NULL || !s)
01201   {
01202     <a class="code" href="util_8h.html#a13">xepprintf</a>(<span class="stringliteral">"passed a NULL string. Abort!\n"</span>);
01203 
01204     <span class="keywordflow">return</span>(<a class="code" href="spf_8h.html#a90a63">NO_POLICY</a>);
01205   }
01206 
01207   <a class="code" href="util_8h.html#a10">xvprintf</a>(<span class="stringliteral">"called with: (%s)\n"</span>, s);
01208 
01209   <span class="keywordflow">if</span> (strncmp(s, <span class="stringliteral">"v="</span>, 2) == 0)
01210   {
01211     <a class="code" href="util_8h.html#a10">xvprintf</a>(<span class="stringliteral">"leaving function; returning %i (VERSION)\n"</span>, <a class="code" href="spf_8h.html#a90a64">VERSION</a>);
01212 
01213     <span class="keywordflow">return</span>(<a class="code" href="spf_8h.html#a90a64">VERSION</a>);
01214   }
01215   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (strncmp(s, <span class="stringliteral">"ip4:"</span>, 4) == 0 )
01216   {
01217     <a class="code" href="util_8h.html#a10">xvprintf</a>(<span class="stringliteral">"leaving function; returning %i (IP4)\n"</span>, <a class="code" href="spf_8h.html#a90a70">IP4</a>);
01218 
01219     <span class="keywordflow">return</span>(<a class="code" href="spf_8h.html#a90a70">IP4</a>);
01220   }
01221   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (strncmp(s, <span class="stringliteral">"ip6:"</span>, 4) == 0)
01222   {
01223     <a class="code" href="util_8h.html#a10">xvprintf</a>(<span class="stringliteral">"leaving function; returning %i (IP6)\n"</span>, <a class="code" href="spf_8h.html#a90a71">IP6</a>);
01224 
01225     <span class="keywordflow">return</span>(<a class="code" href="spf_8h.html#a90a71">IP6</a>);
01226   }
01227   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (strncmp(s, <span class="stringliteral">"all"</span>, 3) == 0)
01228   {
01229     <a class="code" href="util_8h.html#a10">xvprintf</a>(<span class="stringliteral">"leaving function; returning %i (ALL)\n"</span>, <a class="code" href="spf_8h.html#a90a65">ALL</a>);
01230 
01231     <span class="keywordflow">return</span>(<a class="code" href="spf_8h.html#a90a65">ALL</a>);
01232   }
01233   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (strncmp(s, <span class="stringliteral">"mx"</span>, 2) == 0)
01234   {
01235     <a class="code" href="util_8h.html#a10">xvprintf</a>(<span class="stringliteral">"leaving function; returning %i (MX)\n"</span>, <a class="code" href="spf_8h.html#a90a68">MX</a>);
01236 
01237     <span class="keywordflow">return</span>(<a class="code" href="spf_8h.html#a90a68">MX</a>);
01238   }
01239   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (strncmp(s, <span class="stringliteral">"a:"</span>, 2) == 0 || (*s == <span class="charliteral">'a'</span> &amp;&amp; *(s + 1) == <span class="charliteral">'/'</span>)
01240     ||  ((*s == <span class="charliteral">'a'</span>) &amp;&amp; !*(s + 1)))
01241   {
01242     <a class="code" href="util_8h.html#a10">xvprintf</a>(<span class="stringliteral">"leaving function; returning %i (A)\n"</span>, <a class="code" href="spf_8h.html#a90a67">A</a>);
01243 
01244     <span class="keywordflow">return</span>(<a class="code" href="spf_8h.html#a90a67">A</a>);
01245   }
01246   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (strncmp(s, <span class="stringliteral">"ptr"</span>, 3) == 0)
01247   {
01248     <a class="code" href="util_8h.html#a10">xvprintf</a>(<span class="stringliteral">"leaving function; returning %i (PTR)\n"</span>, <a class="code" href="spf_8h.html#a90a69">PTR</a>);
01249 
01250     <span class="keywordflow">return</span>(<a class="code" href="spf_8h.html#a90a69">PTR</a>);
01251   }
01252   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (strncmp(s, <span class="stringliteral">"include:"</span>, 7) == 0)
01253   {
01254     <a class="code" href="util_8h.html#a10">xvprintf</a>(<span class="stringliteral">"leaving function; returning %i (INCLUDE)\n"</span>, <a class="code" href="spf_8h.html#a90a66">INCLUDE</a>);
01255 
01256     <span class="keywordflow">return</span>(<a class="code" href="spf_8h.html#a90a66">INCLUDE</a>);
01257   }
01258   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (strncmp(s, <span class="stringliteral">"exists:"</span>, 6) == 0)
01259   {
01260     <a class="code" href="util_8h.html#a10">xvprintf</a>(<span class="stringliteral">"leaving function; returning %i (EXISTS)\n"</span>, <a class="code" href="spf_8h.html#a90a72">EXISTS</a>);
01261 
01262     <span class="keywordflow">return</span>(<a class="code" href="spf_8h.html#a90a72">EXISTS</a>);
01263   }
01264   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (strncmp(s, <span class="stringliteral">"redirect="</span>, 9) == 0)
01265   {
01266     <a class="code" href="util_8h.html#a10">xvprintf</a>(<span class="stringliteral">"leaving function; returning %i (REDIRECT)\n"</span>, <a class="code" href="spf_8h.html#a90a73">REDIRECT</a>);
01267 
01268     <span class="keywordflow">return</span>(<a class="code" href="spf_8h.html#a90a73">REDIRECT</a>);
01269   }
01270   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (strncmp(s, <span class="stringliteral">"exp="</span>, 3) == 0)
01271   {
01272     <a class="code" href="util_8h.html#a10">xvprintf</a>(<span class="stringliteral">"leaving function; returning %i (EXPLAIN)\n"</span>, <a class="code" href="spf_8h.html#a90a74">EXPLAIN</a>);
01273 
01274     <span class="keywordflow">return</span>(<a class="code" href="spf_8h.html#a90a74">EXPLAIN</a>);
01275   }
01276   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (strncmp(s, <span class="stringliteral">"default"</span>, 7) == 0)
01277   {
01278     <a class="code" href="util_8h.html#a10">xvprintf</a>(<span class="stringliteral">"leaving function; returning %i (DEFAULT)\n"</span>, <a class="code" href="spf_8h.html#a90a75">DEFAULT</a>);
01279 
01280     <span class="keywordflow">return</span>(<a class="code" href="spf_8h.html#a90a75">DEFAULT</a>);
01281   }
01282   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (strstr(s, <span class="stringliteral">":"</span>))
01283   {
01284     <a class="code" href="util_8h.html#a10">xvprintf</a>(<span class="stringliteral">"leaving function; returning %i (UNMECH)\n"</span>, <a class="code" href="spf_8h.html#a90a76">UNMECH</a>);
01285 
01286     <span class="keywordflow">return</span>(<a class="code" href="spf_8h.html#a90a76">UNMECH</a>);
01287   }
01288 
01289   <a class="code" href="util_8h.html#a11">xpprintf</a>(<span class="stringliteral">"leaving function; returning NO_POLICY\n"</span>);
01290   <span class="keywordflow">return</span>(<a class="code" href="spf_8h.html#a90a63">NO_POLICY</a>);
01291 }
01292 
01293 
01294 <span class="comment">/* UTIL_assoc_prefix</span>
01295 <span class="comment">*</span>
01296 <span class="comment">*  Author: James Couzens &lt;jcouzens@codeshare.ca&gt;</span>
01297 <span class="comment">*</span>
01298 <span class="comment">*  Date:   01/28/04</span>
01299 <span class="comment">*</span>
01300 <span class="comment">*  Desc:</span>
01301 <span class="comment">*          Examins s and attempts to determine which SPF_MECHANISM_PREFIX</span>
01302 <span class="comment">*  enumeration the string SPF_MATCHes based on the its contents (which is a</span>
01303 <span class="comment">*  single char.  Upon a SPF_PASS it stores the appropriate value inside of</span>
01304 <span class="comment">*  the passed peer_info structure.  SPF_TRUE upon success, SPF_FALSE upon failure.</span>
01305 <span class="comment">*  Also upon failure SPF_ERROR (SPF_RESULT_TYPE) is stored in peer_info.</span>
01306 <span class="comment">*</span>
01307 <span class="comment">*</span>
01308 <span class="comment">*/</span>
<a name="l01309"></a><a class="code" href="util_8h.html#a47">01309</a> <a class="code" href="spf_8h.html#a35">SPF_BOOL</a> <a class="code" href="util_8h.html#a47">UTIL_assoc_prefix</a>(<a class="code" href="structpeer__info__s.html">peer_info_t</a> *p, <a class="code" href="spf_8h.html#a36">SPF_RESULT</a> res, <span class="keyword">const</span> <span class="keywordtype">char</span> *s)
01310 {
01311   int16_t pos;      <span class="comment">/* position in s string */</span>
01312 
01313 
01314    <span class="comment">/* </span>
01315 <span class="comment">   * for whatever result happens to match the case, a debug string is </span>
01316 <span class="comment">   * printed (if compiled with), the level of recursion is made known through</span>
01317 <span class="comment">   * this. An appropriate SPF_RESULT is assigned to the passed peer_info_t </span>
01318 <span class="comment">   * structure's 'p-&gt;RES' variable.  In addition a short SPF_RESULT string</span>
01319 <span class="comment">   * (here is an example use of the spf_result_t structure spoke of in SPF_init)</span>
01320 <span class="comment">   * is stored in 'p-&gt;rs', and finally an error string is stored in </span>
01321 <span class="comment">   * 'p-&gt;error'.  This string encompasses all SPF query return types though,</span>
01322 <span class="comment">   * it is not only populated upon a parse error, so don't hesitate to reference</span>
01323 <span class="comment">   * it when looking for a verbose explanation as to the result of an SPF parse.</span>
01324 <span class="comment">  */</span>
01325 
01326   <span class="keywordflow">if</span> (s != NULL)
01327   {
01328     <a class="code" href="util_8h.html#a10">xvprintf</a>(<span class="stringliteral">"Entering function (%i) (%s)\n"</span>, res, s);
01329 
01330     <span class="comment">/* support for old school deprecated mechanism "default" */</span>
01331     <span class="keywordflow">if</span> (strncmp(s, <span class="stringliteral">"default"</span>, 7) == 0 &amp;&amp; (pos = <a class="code" href="util_8h.html#a35">UTIL_index</a>(s, <span class="charliteral">'='</span>)) &gt; 0)
01332     {
01333       s += (pos + 1); <span class="comment">/* move past default= */</span>
01334       <span class="keywordflow">if</span> (strncmp(s, <span class="stringliteral">"deny"</span>, 4) == 0)
01335       {
01336         <a class="code" href="util_8h.html#a10">xvprintf</a>(<span class="stringliteral">"Stored SPF_H_FAIL (%i) (%i)\n"</span>,
01337           res, <a class="code" href="spf_8h.html#a88a54">SPF_H_FAIL</a>);
01338 
01339         p-&gt;<a class="code" href="structpeer__info__s.html#o1">RES</a> = <a class="code" href="spf_8h.html#a88a54">SPF_H_FAIL</a>;
01340         p-&gt;<a class="code" href="structpeer__info__s.html#o7">rs</a>  = p-&gt;<a class="code" href="structpeer__info__s.html#o25">spf_result</a>[<a class="code" href="spf_8h.html#a88a54">SPF_H_FAIL</a>].<a class="code" href="structspf__result__t.html#o1">s</a>;
01341 
01342         snprintf(p-&gt;<a class="code" href="structpeer__info__s.html#o24">error</a>, <a class="code" href="spf_8h.html#a16">SPF_MAX_ERROR</a>, <span class="stringliteral">"policy result: (%s) from rule (%s)"</span>,
01343           p-&gt;<a class="code" href="structpeer__info__s.html#o7">rs</a>, p-&gt;<a class="code" href="structpeer__info__s.html#o23">last_m</a>);
01344 
01345         <span class="keywordflow">return</span>(<a class="code" href="spf_8h.html#a87a50">SPF_TRUE</a>);
01346       }
01347       <span class="keywordflow">else</span> <span class="keywordflow">if</span> (strncmp(s, <span class="stringliteral">"pass"</span>, 4) == 0)
01348       {
01349         <a class="code" href="util_8h.html#a10">xvprintf</a>(<span class="stringliteral">"Stored SPF_PASS (%i) (%i)\n"</span>,
01350           res, <a class="code" href="spf_8h.html#a88a51">SPF_PASS</a>);
01351 
01352         p-&gt;<a class="code" href="structpeer__info__s.html#o1">RES</a> = <a class="code" href="spf_8h.html#a88a51">SPF_PASS</a>;
01353         p-&gt;<a class="code" href="structpeer__info__s.html#o7">rs</a>  = p-&gt;<a class="code" href="structpeer__info__s.html#o25">spf_result</a>[<a class="code" href="spf_8h.html#a88a51">SPF_PASS</a>].<a class="code" href="structspf__result__t.html#o1">s</a>;
01354 
01355         snprintf(p-&gt;<a class="code" href="structpeer__info__s.html#o24">error</a>, <a class="code" href="spf_8h.html#a16">SPF_MAX_ERROR</a>, <span class="stringliteral">"policy result: (%s) from rule (%s)"</span>,
01356           p-&gt;<a class="code" href="structpeer__info__s.html#o7">rs</a>, p-&gt;<a class="code" href="structpeer__info__s.html#o23">last_m</a>);
01357 
01358         <span class="keywordflow">return</span>(<a class="code" href="spf_8h.html#a87a50">SPF_TRUE</a>);
01359       }
01360       <span class="keywordflow">else</span> <span class="keywordflow">if</span> (strncmp(s, <span class="stringliteral">"softdeny"</span>, 8) == 0)
01361       {
01362         <a class="code" href="util_8h.html#a10">xvprintf</a>(<span class="stringliteral">"Stored SPF_S_FAIL (%i) (%i)\n"</span>,
01363           res, <a class="code" href="spf_8h.html#a88a53">SPF_S_FAIL</a>);
01364 
01365         p-&gt;<a class="code" href="structpeer__info__s.html#o1">RES</a> = <a class="code" href="spf_8h.html#a88a53">SPF_S_FAIL</a>;
01366         p-&gt;<a class="code" href="structpeer__info__s.html#o7">rs</a>  = p-&gt;<a class="code" href="structpeer__info__s.html#o25">spf_result</a>[<a class="code" href="spf_8h.html#a88a53">SPF_S_FAIL</a>].<a class="code" href="structspf__result__t.html#o1">s</a>;
01367 
01368         snprintf(p-&gt;<a class="code" href="structpeer__info__s.html#o24">error</a>, <a class="code" href="spf_8h.html#a16">SPF_MAX_ERROR</a>, <span class="stringliteral">"policy result: (%s) from rule (%s)"</span>,
01369           p-&gt;<a class="code" href="structpeer__info__s.html#o7">rs</a>, p-&gt;<a class="code" href="structpeer__info__s.html#o23">last_m</a>);
01370 
01371         <span class="keywordflow">return</span>(<a class="code" href="spf_8h.html#a87a50">SPF_TRUE</a>);
01372       }
01373       <span class="keywordflow">else</span> <span class="keywordflow">if</span> (strncmp(s, <span class="stringliteral">"unknown"</span>, 7) == 0)
01374       {
01375         <a class="code" href="util_8h.html#a10">xvprintf</a>(<span class="stringliteral">"Stored SPF_NEUTRAL (%i) (%i)\n"</span>,
01376           res, <a class="code" href="spf_8h.html#a88a56">SPF_NEUTRAL</a>);
01377 
01378         p-&gt;<a class="code" href="structpeer__info__s.html#o1">RES</a> = <a class="code" href="spf_8h.html#a88a56">SPF_NEUTRAL</a>;
01379         p-&gt;<a class="code" href="structpeer__info__s.html#o7">rs</a>  = p-&gt;<a class="code" href="structpeer__info__s.html#o25">spf_result</a>[<a class="code" href="spf_8h.html#a88a56">SPF_NEUTRAL</a>].<a class="code" href="structspf__result__t.html#o1">s</a>;
01380 
01381         snprintf(p-&gt;<a class="code" href="structpeer__info__s.html#o24">error</a>, <a class="code" href="spf_8h.html#a16">SPF_MAX_ERROR</a>, <span class="stringliteral">"policy result: (%s) from rule (%s)"</span>,
01382           p-&gt;<a class="code" href="structpeer__info__s.html#o7">rs</a>, p-&gt;<a class="code" href="structpeer__info__s.html#o23">last_m</a>);
01383 
01384         <span class="keywordflow">return</span>(<a class="code" href="spf_8h.html#a87a50">SPF_TRUE</a>);
01385       }
01386       <span class="keywordflow">else</span> <span class="keywordflow">if</span> (strncmp(s, <span class="stringliteral">"include"</span>, 7) == 0)
01387       {
01388         <a class="code" href="util_8h.html#a10">xvprintf</a>(<span class="stringliteral">"Stored SPF_UNKNOWN (%i) (%i)\n"</span>,
01389           res, <a class="code" href="spf_8h.html#a88a57">SPF_UNKNOWN</a>);
01390 
01391         p-&gt;<a class="code" href="structpeer__info__s.html#o1">RES</a> = <a class="code" href="spf_8h.html#a88a57">SPF_UNKNOWN</a>;
01392         p-&gt;<a class="code" href="structpeer__info__s.html#o7">rs</a>  = p-&gt;<a class="code" href="structpeer__info__s.html#o25">spf_result</a>[<a class="code" href="spf_8h.html#a88a57">SPF_UNKNOWN</a>].<a class="code" href="structspf__result__t.html#o1">s</a>;
01393 
01394         snprintf(p-&gt;<a class="code" href="structpeer__info__s.html#o24">error</a>, <a class="code" href="spf_8h.html#a16">SPF_MAX_ERROR</a>, <span class="stringliteral">"policy result: (%s) from rule (%s)"</span>,
01395           p-&gt;<a class="code" href="structpeer__info__s.html#o7">rs</a>, p-&gt;<a class="code" href="structpeer__info__s.html#o23">last_m</a>);
01396 
01397         <span class="keywordflow">return</span>(<a class="code" href="spf_8h.html#a87a50">SPF_TRUE</a>);
01398       }
01399       <span class="keywordflow">else</span>
01400       {
01401         <a class="code" href="util_8h.html#a10">xvprintf</a>(<span class="stringliteral">"Stored SPF_ERROR (%i) (%i)\n"</span>,
01402           res, <a class="code" href="spf_8h.html#a88a55">SPF_ERROR</a>);
01403 
01404         p-&gt;<a class="code" href="structpeer__info__s.html#o1">RES</a> = <a class="code" href="spf_8h.html#a88a57">SPF_UNKNOWN</a>;
01405         p-&gt;<a class="code" href="structpeer__info__s.html#o7">rs</a>  = p-&gt;<a class="code" href="structpeer__info__s.html#o25">spf_result</a>[<a class="code" href="spf_8h.html#a88a57">SPF_UNKNOWN</a>].<a class="code" href="structspf__result__t.html#o1">s</a>;
01406 
01407         snprintf(p-&gt;<a class="code" href="structpeer__info__s.html#o24">error</a>, <a class="code" href="spf_8h.html#a16">SPF_MAX_ERROR</a>, <span class="stringliteral">"policy result: (%s) from rule (%s)"</span>,
01408           p-&gt;<a class="code" href="structpeer__info__s.html#o7">rs</a>, p-&gt;<a class="code" href="structpeer__info__s.html#o23">last_m</a>);
01409 
01410         <span class="keywordflow">return</span>(<a class="code" href="spf_8h.html#a87a49">SPF_FALSE</a>);
01411       }
01412     }
01413   }
01414 
01415   <span class="keywordflow">switch</span> (res)
01416   {
01417 
01418     <span class="comment">/* */</span>
01419     <span class="keywordflow">case</span> <a class="code" href="spf_8h.html#a88a51">SPF_PASS</a>:
01420       <a class="code" href="util_8h.html#a10">xvprintf</a>(<span class="stringliteral">"Stored SPF_PASS (%i) (%i)\n"</span>,
01421         res, <a class="code" href="spf_8h.html#a88a51">SPF_PASS</a>);
01422 
01423       p-&gt;<a class="code" href="structpeer__info__s.html#o1">RES</a> = <a class="code" href="spf_8h.html#a88a51">SPF_PASS</a>;
01424       p-&gt;<a class="code" href="structpeer__info__s.html#o7">rs</a>  = p-&gt;<a class="code" href="structpeer__info__s.html#o25">spf_result</a>[<a class="code" href="spf_8h.html#a88a51">SPF_PASS</a>].<a class="code" href="structspf__result__t.html#o1">s</a>;
01425 
01426       snprintf(p-&gt;<a class="code" href="structpeer__info__s.html#o24">error</a>, <a class="code" href="spf_8h.html#a16">SPF_MAX_ERROR</a>, <span class="stringliteral">"policy result: (%s) from rule (%s)"</span>,
01427         p-&gt;<a class="code" href="structpeer__info__s.html#o7">rs</a>, p-&gt;<a class="code" href="structpeer__info__s.html#o23">last_m</a>);
01428 
01429       <span class="keywordflow">return</span>(<a class="code" href="spf_8h.html#a87a50">SPF_TRUE</a>);
01430 
01431    <span class="comment">/* */</span>
01432     <span class="keywordflow">case</span> <a class="code" href="spf_8h.html#a88a52">SPF_NONE</a>:
01433       <a class="code" href="util_8h.html#a10">xvprintf</a>(<span class="stringliteral">"Stored SPF_NONE (%i) (%i)\n"</span>,
01434         res, <a class="code" href="spf_8h.html#a88a52">SPF_NONE</a>);
01435 
01436       p-&gt;<a class="code" href="structpeer__info__s.html#o1">RES</a> = <a class="code" href="spf_8h.html#a88a52">SPF_NONE</a>;
01437       p-&gt;<a class="code" href="structpeer__info__s.html#o7">rs</a>  = p-&gt;<a class="code" href="structpeer__info__s.html#o25">spf_result</a>[<a class="code" href="spf_8h.html#a88a52">SPF_NONE</a>].<a class="code" href="structspf__result__t.html#o1">s</a>;
01438 
01439       snprintf(p-&gt;<a class="code" href="structpeer__info__s.html#o24">error</a>, <a class="code" href="spf_8h.html#a16">SPF_MAX_ERROR</a>, <span class="stringliteral">"policy result: (%s) from rule (%s)"</span>,
01440         p-&gt;<a class="code" href="structpeer__info__s.html#o7">rs</a>, p-&gt;<a class="code" href="structpeer__info__s.html#o23">last_m</a>);
01441 
01442       <span class="keywordflow">return</span>(<a class="code" href="spf_8h.html#a87a50">SPF_TRUE</a>);
01443 
01444    <span class="comment">/* */</span>
01445     <span class="keywordflow">case</span> <a class="code" href="spf_8h.html#a88a53">SPF_S_FAIL</a>:
01446       <a class="code" href="util_8h.html#a10">xvprintf</a>(<span class="stringliteral">"Stored SPF_S_FAIL (%i) (%i)\n"</span>,
01447         res, <a class="code" href="spf_8h.html#a88a53">SPF_S_FAIL</a>);
01448 
01449       p-&gt;<a class="code" href="structpeer__info__s.html#o1">RES</a> = <a class="code" href="spf_8h.html#a88a53">SPF_S_FAIL</a>;
01450       p-&gt;<a class="code" href="structpeer__info__s.html#o7">rs</a>  = p-&gt;<a class="code" href="structpeer__info__s.html#o25">spf_result</a>[<a class="code" href="spf_8h.html#a88a53">SPF_S_FAIL</a>].<a class="code" href="structspf__result__t.html#o1">s</a>;
01451 
01452       snprintf(p-&gt;<a class="code" href="structpeer__info__s.html#o24">error</a>, <a class="code" href="spf_8h.html#a16">SPF_MAX_ERROR</a>, <span class="stringliteral">"policy result: (%s) from rule (%s)"</span>,
01453         p-&gt;<a class="code" href="structpeer__info__s.html#o7">rs</a>, p-&gt;<a class="code" href="structpeer__info__s.html#o23">last_m</a>);
01454 
01455       <span class="keywordflow">return</span>(<a class="code" href="spf_8h.html#a87a50">SPF_TRUE</a>);
01456 
01457     <span class="comment">/* */</span>
01458     <span class="keywordflow">case</span> <a class="code" href="spf_8h.html#a88a54">SPF_H_FAIL</a>:
01459       <a class="code" href="util_8h.html#a10">xvprintf</a>(<span class="stringliteral">"Stored SPF_H_FAIL (%i) (%i)\n"</span>,
01460         res, <a class="code" href="spf_8h.html#a88a54">SPF_H_FAIL</a>);
01461 
01462       p-&gt;<a class="code" href="structpeer__info__s.html#o1">RES</a> = <a class="code" href="spf_8h.html#a88a54">SPF_H_FAIL</a>;
01463       p-&gt;<a class="code" href="structpeer__info__s.html#o7">rs</a>  = p-&gt;<a class="code" href="structpeer__info__s.html#o25">spf_result</a>[<a class="code" href="spf_8h.html#a88a54">SPF_H_FAIL</a>].<a class="code" href="structspf__result__t.html#o1">s</a>;
01464 
01465       snprintf(p-&gt;<a class="code" href="structpeer__info__s.html#o24">error</a>, <a class="code" href="spf_8h.html#a16">SPF_MAX_ERROR</a>, <span class="stringliteral">"policy result: (%s) from rule (%s)"</span>,
01466         p-&gt;<a class="code" href="structpeer__info__s.html#o7">rs</a>, p-&gt;<a class="code" href="structpeer__info__s.html#o23">last_m</a>);
01467 
01468       <span class="keywordflow">return</span>(<a class="code" href="spf_8h.html#a87a50">SPF_TRUE</a>);
01469 
01470     <span class="comment">/* */</span>
01471     <span class="keywordflow">case</span> <a class="code" href="spf_8h.html#a88a56">SPF_NEUTRAL</a>:
01472       <a class="code" href="util_8h.html#a10">xvprintf</a>(<span class="stringliteral">"Stored SPF_NEUTRAL (%i) (%i)\n"</span>,
01473         res, <a class="code" href="spf_8h.html#a88a56">SPF_NEUTRAL</a>);
01474 
01475       p-&gt;<a class="code" href="structpeer__info__s.html#o1">RES</a> = <a class="code" href="spf_8h.html#a88a56">SPF_NEUTRAL</a>;
01476       p-&gt;<a class="code" href="structpeer__info__s.html#o7">rs</a>  = p-&gt;<a class="code" href="structpeer__info__s.html#o25">spf_result</a>[<a class="code" href="spf_8h.html#a88a56">SPF_NEUTRAL</a>].<a class="code" href="structspf__result__t.html#o1">s</a>;
01477 
01478       snprintf(p-&gt;<a class="code" href="structpeer__info__s.html#o24">error</a>, <a class="code" href="spf_8h.html#a16">SPF_MAX_ERROR</a>, <span class="stringliteral">"policy result: (%s) from rule (%s)"</span>,
01479         p-&gt;<a class="code" href="structpeer__info__s.html#o7">rs</a>, p-&gt;<a class="code" href="structpeer__info__s.html#o23">last_m</a>);
01480 
01481       <span class="keywordflow">return</span>(<a class="code" href="spf_8h.html#a87a50">SPF_TRUE</a>);
01482 
01483     <span class="comment">/* */</span>
01484     <span class="keywordflow">case</span> <a class="code" href="spf_8h.html#a88a57">SPF_UNKNOWN</a>:
01485       <a class="code" href="util_8h.html#a10">xvprintf</a>(<span class="stringliteral">"Stored SPF_UNKNOWN (%i) (%i)\n"</span>,
01486         res, <a class="code" href="spf_8h.html#a88a57">SPF_UNKNOWN</a>);
01487 
01488       p-&gt;<a class="code" href="structpeer__info__s.html#o1">RES</a> = <a class="code" href="spf_8h.html#a88a57">SPF_UNKNOWN</a>;
01489       p-&gt;<a class="code" href="structpeer__info__s.html#o7">rs</a>  = p-&gt;<a class="code" href="structpeer__info__s.html#o25">spf_result</a>[<a class="code" href="spf_8h.html#a88a57">SPF_UNKNOWN</a>].<a class="code" href="structspf__result__t.html#o1">s</a>;
01490 
01491       snprintf(p-&gt;<a class="code" href="structpeer__info__s.html#o24">error</a>, <a class="code" href="spf_8h.html#a16">SPF_MAX_ERROR</a>, <span class="stringliteral">"policy result: (%s) from rule (%s)"</span>,
01492         p-&gt;<a class="code" href="structpeer__info__s.html#o7">rs</a>, p-&gt;<a class="code" href="structpeer__info__s.html#o23">last_m</a>);
01493 
01494       <span class="keywordflow">return</span>(<a class="code" href="spf_8h.html#a87a50">SPF_TRUE</a>);
01495 
01496    <span class="comment">/* */</span>
01497     <span class="keywordflow">case</span> <a class="code" href="spf_8h.html#a88a55">SPF_ERROR</a>:
01498       <a class="code" href="util_8h.html#a10">xvprintf</a>(<span class="stringliteral">"Stored SPF_ERROR (%i) (%i)\n"</span>,
01499         p, <a class="code" href="spf_8h.html#a88a55">SPF_ERROR</a>);
01500 
01501       p-&gt;<a class="code" href="structpeer__info__s.html#o1">RES</a> = <a class="code" href="spf_8h.html#a88a55">SPF_ERROR</a>;
01502       p-&gt;<a class="code" href="structpeer__info__s.html#o7">rs</a>  = p-&gt;<a class="code" href="structpeer__info__s.html#o25">spf_result</a>[<a class="code" href="spf_8h.html#a88a55">SPF_ERROR</a>].<a class="code" href="structspf__result__t.html#o1">s</a>;
01503 
01504       snprintf(p-&gt;<a class="code" href="structpeer__info__s.html#o24">error</a>, <a class="code" href="spf_8h.html#a16">SPF_MAX_ERROR</a>, <span class="stringliteral">"policy result: (%s) from rule (%s)"</span>,
01505         p-&gt;<a class="code" href="structpeer__info__s.html#o7">rs</a>, p-&gt;<a class="code" href="structpeer__info__s.html#o23">last_m</a>);
01506 
01507       <span class="keywordflow">return</span>(<a class="code" href="spf_8h.html#a87a50">SPF_TRUE</a>);
01508 
01509     <span class="comment">/* */</span>
01510     <span class="keywordflow">case</span> <a class="code" href="spf_8h.html#a88a58">SPF_UNMECH</a>:
01511       <a class="code" href="util_8h.html#a10">xvprintf</a>(<span class="stringliteral">"Stored SPF_UNMECH (%i) (%i)\n"</span>,
01512         res, <a class="code" href="spf_8h.html#a88a58">SPF_UNMECH</a>);
01513 
01514       p-&gt;<a class="code" href="structpeer__info__s.html#o1">RES</a> = <a class="code" href="spf_8h.html#a88a58">SPF_UNMECH</a>;
01515       p-&gt;<a class="code" href="structpeer__info__s.html#o7">rs</a>  = p-&gt;<a class="code" href="structpeer__info__s.html#o25">spf_result</a>[<a class="code" href="spf_8h.html#a88a58">SPF_UNMECH</a>].<a class="code" href="structspf__result__t.html#o1">s</a>;
01516 
01517       snprintf(p-&gt;<a class="code" href="structpeer__info__s.html#o24">error</a>, <a class="code" href="spf_8h.html#a16">SPF_MAX_ERROR</a>, <span class="stringliteral">"policy result: (%s) from rule (%s)"</span>,
01518         p-&gt;<a class="code" href="structpeer__info__s.html#o7">rs</a>, p-&gt;<a class="code" href="structpeer__info__s.html#o23">last_m</a>);
01519 
01520       <span class="keywordflow">return</span>(<a class="code" href="spf_8h.html#a87a50">SPF_TRUE</a>);
01521 
01522     <span class="comment">/* */</span>
01523     <span class="keywordflow">default</span>:
01524       <a class="code" href="util_8h.html#a10">xvprintf</a>(<span class="stringliteral">"Stored SPF_PASS (%i) (%i)\n"</span>,
01525         res, <a class="code" href="spf_8h.html#a88a51">SPF_PASS</a>);
01526 
01527       p-&gt;<a class="code" href="structpeer__info__s.html#o1">RES</a> = <a class="code" href="spf_8h.html#a88a51">SPF_PASS</a>;
01528       p-&gt;<a class="code" href="structpeer__info__s.html#o7">rs</a>  = p-&gt;<a class="code" href="structpeer__info__s.html#o25">spf_result</a>[<a class="code" href="spf_8h.html#a88a51">SPF_PASS</a>].<a class="code" href="structspf__result__t.html#o1">s</a>;
01529 
01530       snprintf(p-&gt;<a class="code" href="structpeer__info__s.html#o24">error</a>, <a class="code" href="spf_8h.html#a16">SPF_MAX_ERROR</a>, <span class="stringliteral">"policy result: (%s) from rule (%s)"</span>,
01531         p-&gt;<a class="code" href="structpeer__info__s.html#o7">rs</a>, p-&gt;<a class="code" href="structpeer__info__s.html#o23">last_m</a>);
01532 
01533       <span class="keywordflow">return</span>(<a class="code" href="spf_8h.html#a87a50">SPF_TRUE</a>);
01534   }
01535 
01536   <a class="code" href="util_8h.html#a13">xepprintf</a>(<span class="stringliteral">"leaving function; returning SPF_FALSE.\n"</span>);
01537 
01538   <span class="keywordflow">return</span>(<a class="code" href="spf_8h.html#a87a49">SPF_FALSE</a>);
01539 }
01540 
01541 
01542 <span class="comment">/* UTIL_get_mech_prefix</span>
01543 <span class="comment">*</span>
01544 <span class="comment">*  Author: James Couzens &lt;jcouzens@codeshare.ca&gt;</span>
01545 <span class="comment">*</span>
01546 <span class="comment">*  Date:   12/31/03</span>
01547 <span class="comment">*</span>
01548 <span class="comment">*  Desc:</span>
01549 <span class="comment">*          Examins s and attempts to determine which SPF_RESULT_P</span>
01550 <span class="comment">*  enumeration the string SPF_MATCHes based on the its contents (which is a</span>
01551 <span class="comment">*  single char.  Returns SPF_PASS if a valid prefix is not specified.</span>
01552 <span class="comment">*  Valid prefixes are: + (permit), - (deny), ~ (softfail) and ? (SPF_NEUTRAL).</span>
01553 <span class="comment">*</span>
01554 <span class="comment">*/</span>
<a name="l01555"></a><a class="code" href="util_8h.html#a46">01555</a> <a class="code" href="spf_8h.html#a36">SPF_RESULT</a> <a class="code" href="util_8h.html#a46">UTIL_get_mech_prefix</a>(<a class="code" href="structpeer__info__s.html">peer_info_t</a> *p, <span class="keyword">const</span> <span class="keywordtype">char</span> *s)
01556 {
01557   int16_t pos;    <span class="comment">/* position in s */</span>
01558 
01559 
01560   <span class="keywordflow">if</span> (s == NULL)
01561   {
01562     <a class="code" href="util_8h.html#a13">xepprintf</a>(<span class="stringliteral">"passed a NULL string.  Abort!\n"</span>);
01563 
01564     <span class="keywordflow">return</span>(<a class="code" href="spf_8h.html#a88a55">SPF_ERROR</a>);
01565   }
01566 
01567   <a class="code" href="util_8h.html#a9">xprintf</a>(<span class="stringliteral">"called with char: (%s)\n"</span>, s);
01568   snprintf(p-&gt;<a class="code" href="structpeer__info__s.html#o23">last_m</a>, <a class="code" href="spf_8h.html#a14">SPF_MAX_HNAME</a>, <span class="stringliteral">"%s"</span>, s);
01569 
01570   <span class="keywordflow">switch</span> (*s)
01571   {
01572 
01573     <span class="comment">/* */</span>
01574     <span class="keywordflow">case</span> <span class="charliteral">'+'</span>:
01575       p-&gt;<a class="code" href="structpeer__info__s.html#o2">RES_P</a> = <a class="code" href="spf_8h.html#a88a51">SPF_PASS</a>;
01576       <a class="code" href="util_8h.html#a10">xvprintf</a>(<span class="stringliteral">"leaving function; returning SPF_PASS (%s) %i\n"</span>,
01577         s, <a class="code" href="spf_8h.html#a88a51">SPF_PASS</a>);
01578 
01579       <span class="keywordflow">return</span>(<a class="code" href="spf_8h.html#a88a51">SPF_PASS</a>);
01580 
01581 
01582     <span class="comment">/* */</span>
01583     <span class="keywordflow">case</span> <span class="charliteral">'-'</span>:
01584        p-&gt;<a class="code" href="structpeer__info__s.html#o2">RES_P</a> = <a class="code" href="spf_8h.html#a88a54">SPF_H_FAIL</a>;
01585       <a class="code" href="util_8h.html#a10">xvprintf</a>(<span class="stringliteral">"leaving function; returning SPF_H_FAIL (%s) %i\n"</span>,
01586         s, <a class="code" href="spf_8h.html#a88a54">SPF_H_FAIL</a>);
01587 
01588        <span class="keywordflow">return</span>(<a class="code" href="spf_8h.html#a88a54">SPF_H_FAIL</a>);
01589 
01590     <span class="comment">/* */</span>
01591     <span class="keywordflow">case</span> <span class="charliteral">'?'</span>:
01592       p-&gt;<a class="code" href="structpeer__info__s.html#o2">RES_P</a> = <a class="code" href="spf_8h.html#a88a56">SPF_NEUTRAL</a>;
01593       <a class="code" href="util_8h.html#a10">xvprintf</a>(<span class="stringliteral">"leaving function; returning SPF_NEUTRAL (%s) %i\n"</span>,
01594         s, <a class="code" href="spf_8h.html#a88a56">SPF_NEUTRAL</a>);
01595 
01596       <span class="keywordflow">return</span>(<a class="code" href="spf_8h.html#a88a56">SPF_NEUTRAL</a>);
01597 
01598     <span class="comment">/* */</span>
01599     <span class="keywordflow">case</span> <span class="charliteral">'~'</span>:
01600       p-&gt;<a class="code" href="structpeer__info__s.html#o2">RES_P</a> = <a class="code" href="spf_8h.html#a88a53">SPF_S_FAIL</a>;
01601       <a class="code" href="util_8h.html#a10">xvprintf</a>(<span class="stringliteral">"leaving function; returning SPF_S_FAIL (%s) %i\n"</span>,
01602         s, <a class="code" href="spf_8h.html#a88a53">SPF_S_FAIL</a>);
01603 
01604       <span class="keywordflow">return</span>(<a class="code" href="spf_8h.html#a88a53">SPF_S_FAIL</a>);
01605 
01606     <span class="comment">/* */</span>
01607     <span class="keywordflow">default</span>:
01608       <span class="keywordflow">if</span> (p-&gt;<a class="code" href="structpeer__info__s.html#o0">ALL</a> == <a class="code" href="spf_8h.html#a87a50">SPF_TRUE</a>)
01609       {
01610         p-&gt;<a class="code" href="structpeer__info__s.html#o2">RES_P</a> = <a class="code" href="spf_8h.html#a88a56">SPF_NEUTRAL</a>;
01611         <a class="code" href="util_8h.html#a10">xvprintf</a>(<span class="stringliteral">"leaving function; returning (def) SPF_NEUTRAL (%s) %i\n"</span>,
01612           s, <a class="code" href="spf_8h.html#a88a56">SPF_NEUTRAL</a>);
01613       }
01614       <span class="keywordflow">else</span>
01615       {
01616         p-&gt;<a class="code" href="structpeer__info__s.html#o2">RES_P</a> = <a class="code" href="spf_8h.html#a88a51">SPF_PASS</a>;
01617         <a class="code" href="util_8h.html#a10">xvprintf</a>(<span class="stringliteral">"leaving function; returning (def) SPF_PASS (%s) %i\n"</span>,
01618           s, <a class="code" href="spf_8h.html#a88a51">SPF_PASS</a>);
01619       }
01620 
01621     <a class="code" href="util_8h.html#a10">xvprintf</a>(<span class="stringliteral">"leaving function; returning (%i)\n"</span>, p-&gt;<a class="code" href="structpeer__info__s.html#o2">RES_P</a>);
01622 
01623     <span class="keywordflow">return</span>(p-&gt;<a class="code" href="structpeer__info__s.html#o2">RES_P</a>);
01624   } <span class="comment">/* switch */</span>
01625 
01626    <span class="comment">/*</span>
01627 <span class="comment">   * The code in the following statement is for the</span>
01628 <span class="comment">   * deprecated mechanism "default" and is only here to attempt</span>
01629 <span class="comment">   * to support exceptionally tardy early adopters whom likely</span>
01630 <span class="comment">   * at this time no longer exist.  As such this code is not</span>
01631 <span class="comment">   * present in the current development versions of this library</span>
01632 <span class="comment">  */</span>
01633   <span class="keywordflow">if</span> ((pos = <a class="code" href="util_8h.html#a35">UTIL_index</a>(s, <span class="charliteral">'='</span>)) &gt; 0)
01634   {
01635     s += (pos + 1); <span class="comment">/* move past default= */</span>
01636 
01637     <span class="keywordflow">if</span> (strncmp(s, <span class="stringliteral">"deny"</span>, 4) == 0)
01638     {
01639       p-&gt;<a class="code" href="structpeer__info__s.html#o2">RES_P</a> = <a class="code" href="spf_8h.html#a88a54">SPF_H_FAIL</a>;
01640       <a class="code" href="util_8h.html#a10">xvprintf</a>(<span class="stringliteral">"leaving function; returning SPF_H_FAIL on (%s)\n"</span>, s);
01641 
01642       <span class="keywordflow">return</span>(<a class="code" href="spf_8h.html#a88a54">SPF_H_FAIL</a>);
01643     }
01644     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (strncmp(s, <span class="stringliteral">"pass"</span>, 4) == 0)
01645     {
01646       p-&gt;<a class="code" href="structpeer__info__s.html#o2">RES_P</a> = <a class="code" href="spf_8h.html#a88a51">SPF_PASS</a>;
01647       <a class="code" href="util_8h.html#a10">xvprintf</a>(<span class="stringliteral">"leaving function; returning SPF_PASS on (%s)\n"</span>, s);
01648 
01649       <span class="keywordflow">return</span>(<a class="code" href="spf_8h.html#a88a51">SPF_PASS</a>);
01650     }
01651     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (strncmp(s, <span class="stringliteral">"softdeny"</span>, 8) == 0)
01652     {
01653       p-&gt;<a class="code" href="structpeer__info__s.html#o2">RES_P</a> = <a class="code" href="spf_8h.html#a88a53">SPF_S_FAIL</a>;
01654       <a class="code" href="util_8h.html#a10">xvprintf</a>(<span class="stringliteral">"leaving function; returning SPF_S_FAIL on (%s)\n"</span>, s);
01655 
01656       <span class="keywordflow">return</span>(<a class="code" href="spf_8h.html#a88a53">SPF_S_FAIL</a>);
01657     }
01658     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (strncmp(s, <span class="stringliteral">"unknown"</span>, 7) == 0)
01659     {
01660       p-&gt;<a class="code" href="structpeer__info__s.html#o2">RES_P</a> = <a class="code" href="spf_8h.html#a88a56">SPF_NEUTRAL</a>;
01661       <a class="code" href="util_8h.html#a10">xvprintf</a>(<span class="stringliteral">"leaving function; returning SPF_NEUTRAL on (%s)\n"</span>, s);
01662 
01663       <span class="keywordflow">return</span>(<a class="code" href="spf_8h.html#a88a56">SPF_NEUTRAL</a>);
01664     }
01665     <span class="keywordflow">else</span>
01666     {
01667       <a class="code" href="util_8h.html#a10">xvprintf</a>(<span class="stringliteral">"leaving function; returning SPF_NEUTRAL on (%s)\n"</span>, s);
01668 
01669       <span class="keywordflow">return</span>(<a class="code" href="spf_8h.html#a88a56">SPF_NEUTRAL</a>);
01670     }
01671   }
01672 
01673   <a class="code" href="util_8h.html#a10">xvprintf</a>(<span class="stringliteral">"leaving function; returning SPF_ERROR on (%s)\n"</span>, s);
01674 
01675   <span class="keywordflow">return</span>(<a class="code" href="spf_8h.html#a88a55">SPF_ERROR</a>);
01676 }
01677 
01678 
01679 <span class="comment">/* UTIL_expand_ip</span>
01680 <span class="comment">*</span>
01681 <span class="comment">*  Author: James Couzens &lt;jcouzens@codeshare.ca&gt;</span>
01682 <span class="comment">*</span>
01683 <span class="comment">*  Date:   12/26/03</span>
01684 <span class="comment">*</span>
01685 <span class="comment">*  Desc:</span>
01686 <span class="comment">*          Expands an ip4 policy mechanism string into a policy_addr_t</span>
01687 <span class="comment">*  structure which it allocates memory for and then returns.  The RFC</span>
01688 <span class="comment">*  specifies that if a cidr block is not specified then /32 isused.</span>
01689 <span class="comment">*</span>
01690 <span class="comment">*  On success returns a pointer to a policy_addr_t structure, on</span>
01691 <span class="comment">*  SPF_ERROR returns NULL.</span>
01692 <span class="comment">*</span>
01693 <span class="comment">*/</span>
<a name="l01694"></a><a class="code" href="util_8h.html#a48">01694</a> <a class="code" href="structpolicy__addr__s.html">policy_addr_t</a> *<a class="code" href="util_8h.html#a48">UTIL_expand_ip</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *s)
01695 {
01696   int8_t cidr = 0;               <span class="comment">/* temporary storage for netmask */</span>
01697 
01698   size_t len;                    <span class="comment">/* length of string passed */</span>
01699   size_t pos;                    <span class="comment">/* position of break points in string */</span>
01700 
01701   <span class="keywordtype">char</span> *ip;                      <span class="comment">/* temporary storage for ip address */</span>
01702 
01703   <span class="keyword">const</span> <span class="keywordtype">char</span> *token_ptr;         <span class="comment">/* our position in the token */</span>
01704 
01705   <a class="code" href="structpolicy__addr__s.html">policy_addr_t</a> *policy_addr;    <span class="comment">/* ip/mask return structure */</span>
01706 
01707 
01708   <span class="keywordflow">if</span> (s == NULL)
01709   {
01710     <a class="code" href="util_8h.html#a13">xepprintf</a>(<span class="stringliteral">"passed a NULL string.  Abort!\n"</span>);
01711 
01712     <span class="keywordflow">return</span>(NULL);
01713   }
01714 
01715   len = strlen(s);
01716   token_ptr = s;
01717 
01718   <a class="code" href="util_8h.html#a10">xvprintf</a>(<span class="stringliteral">"called with string: (%s)\n"</span>, token_ptr);
01719 
01720   <span class="keywordflow">if</span> ((pos = <a class="code" href="util_8h.html#a35">UTIL_index</a>(token_ptr, <span class="charliteral">':'</span>)) == 0)
01721   {
01722     <a class="code" href="util_8h.html#a10">xvprintf</a>(<span class="stringliteral">"SPF_ERROR: Unable to get position on token (%s)\n"</span>,
01723       token_ptr);
01724 
01725     <span class="keywordflow">return</span>(NULL);
01726   }
01727 
01728   <span class="comment">/* jump past the ip4: portion */</span>
01729   token_ptr += pos + 1;
01730 
01731   policy_addr = <a class="code" href="util_8h.html#a4">xmalloc</a>(<a class="code" href="util_8h.html#a3">SIZEOF</a>(<a class="code" href="structpolicy__addr__s.html">policy_addr_t</a>));
01732 
01733   <span class="comment">/* jump past the ip4: portion (to get length of ip) */</span>
01734   <span class="keywordflow">if</span> ((pos = <a class="code" href="util_8h.html#a35">UTIL_index</a>(token_ptr, <span class="charliteral">'/'</span>)) == 0)
01735   {
01736     <a class="code" href="util_8h.html#a10">xvprintf</a>(<span class="stringliteral">"Unable to get position on token (%s), assuming /32 cidr "</span> \
01737       <span class="stringliteral">"block\n"</span>, token_ptr);
01738 
01739     pos = strlen(token_ptr);
01740     cidr = 32;
01741   }
01742 
01743   <span class="comment">/* allocate space and dump the ip address there */</span>
01744   ip = <a class="code" href="util_8h.html#a8">xstrndup</a>(token_ptr, (pos + 1));
01745 
01746   <span class="comment">/* copy it over to the policy_addr structure */</span>
01747   <span class="keywordflow">if</span> ((inet_pton(AF_INET, ip, &amp;policy_addr-&gt;<a class="code" href="structpolicy__addr__s.html#o2">addr</a>)) == 0)
01748   {
01749     <a class="code" href="util_8h.html#a10">xvprintf</a>(<span class="stringliteral">"SPF_ERROR: inet_pton unable to convert ip to binary "</span> \
01750       <span class="stringliteral">"(%s)\n"</span>, ip);
01751 
01752     <a class="code" href="util_8h.html#a6">xfree</a>(ip);
01753     <span class="keywordflow">return</span>(NULL);
01754   }
01755 
01756   <span class="keywordflow">if</span> (cidr != 32)
01757   {
01758     token_ptr += (pos + 1);    <span class="comment">/* skip over the forward slash */</span>
01759     cidr = atoi(token_ptr);    <span class="comment">/* convert the string to an integer */</span>
01760   }
01761 
01762   <a class="code" href="util_8h.html#a6">xfree</a>(ip);
01763 
01764   <span class="keywordflow">if</span> ((cidr &lt; 0) || (cidr &gt; 32))
01765   {
01766     <a class="code" href="util_8h.html#a10">xvprintf</a>(<span class="stringliteral">"ERROR: cidr violation (%u)\n"</span>, cidr);
01767 
01768     <span class="keywordflow">return</span>(NULL);
01769   }
01770 
01771   policy_addr-&gt;<a class="code" href="structpolicy__addr__s.html#o1">cidr</a> = cidr;    <span class="comment">/* copy it over to the policy_addr structure */</span>
01772 
01773   <a class="code" href="util_8h.html#a10">xvprintf</a>(<span class="stringliteral">"CIDR: (%i) IP: (%s)\n"</span>,
01774     policy_addr-&gt;<a class="code" href="structpolicy__addr__s.html#o1">cidr</a>, inet_ntoa(policy_addr-&gt;<a class="code" href="structpolicy__addr__s.html#o2">addr</a>));
01775 
01776   <span class="keywordflow">return</span>(policy_addr);
01777 }
01778 
01779 
01780 <span class="comment">/*  UTIL_is_ip</span>
01781 <span class="comment">*</span>
01782 <span class="comment">*  Author: James Couzens &lt;jcouzens@codeshare.ca&gt;</span>
01783 <span class="comment">*</span>
01784 <span class="comment">*  Date:   01/18/04</span>
01785 <span class="comment">*</span>
01786 <span class="comment">*  Desc:</span>
01787 <span class="comment">*         Is the passed string (limited to between 0 - 255 by type)</span>
01788 <span class="comment">*  contains a valid ip address or not.  I'm not sure if this is useful</span>
01789 <span class="comment">*  anymore but at one point I was using it to tell if the passed macro</span>
01790 <span class="comment">*  contained an ip address or not when passed as a string.</span>
01791 <span class="comment">*</span>
01792 <span class="comment">*/</span>
<a name="l01793"></a><a class="code" href="util_8h.html#a49">01793</a> <a class="code" href="spf_8h.html#a35">SPF_BOOL</a> <a class="code" href="util_8h.html#a49">UTIL_is_ip</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *<span class="keywordtype">id</span>)
01794 {
01795   u_int8_t i = 0;    <span class="comment">/* utility */</span>
01796 
01797   <span class="keywordflow">if</span> (!<span class="keywordtype">id</span>)
01798   {
01799     <a class="code" href="util_8h.html#a13">xepprintf</a>(<span class="stringliteral">"called without an IP address!\n"</span>);
01800   
01801     <span class="keywordflow">return</span>(<a class="code" href="spf_8h.html#a87a49">SPF_FALSE</a>);
01802   }
01803 
01804   <a class="code" href="util_8h.html#a10">xvprintf</a>(<span class="stringliteral">"called with address: (%s)\n"</span>, <span class="keywordtype">id</span>);
01805 
01806   <span class="keywordflow">while</span> (*id)
01807   {
01808     <span class="keywordflow">if</span> (*<span class="keywordtype">id</span> == <span class="charliteral">'.'</span>)
01809     {
01810       i++;
01811     }
01812     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (isdigit(*<span class="keywordtype">id</span>) == 0)
01813     {
01814       <span class="keywordflow">return</span>(<a class="code" href="spf_8h.html#a87a49">SPF_FALSE</a>);
01815     }
01816     <span class="keywordtype">id</span>++;
01817   }
01818 
01819   <span class="keywordflow">if</span> (i == 3)
01820   {
01821     <span class="keywordflow">return</span>(<a class="code" href="spf_8h.html#a87a50">SPF_TRUE</a>);
01822   }
01823 
01824   <a class="code" href="util_8h.html#a11">xpprintf</a>(<span class="stringliteral">"leaving function; returning SPF_FALSE\n"</span>);
01825 
01826   <span class="keywordflow">return</span>(<a class="code" href="spf_8h.html#a87a49">SPF_FALSE</a>);
01827 }
01828 
01829 
01830 <span class="comment">/* UTIL_rev_addr</span>
01831 <span class="comment">*</span>
01832 <span class="comment">*  Author: James Couzens &lt;jcouzens@codeshare.ca&gt;</span>
01833 <span class="comment">*</span>
01834 <span class="comment">*  Date:   01/04/04</span>
01835 <span class="comment">*</span>
01836 <span class="comment">*  Desc:</span>
01837 <span class="comment">*          Using a passed ip address it will reverse it and slap</span>
01838 <span class="comment">*  .in-addr.arpa on the end of it making it ready for a proper PTR query</span>
01839 <span class="comment">*</span>
01840 <span class="comment">*  Notes:  Write additional code to handle IP6 addresses</span>
01841 <span class="comment">*</span>
01842 <span class="comment">*/</span>
<a name="l01843"></a><a class="code" href="util_8h.html#a50">01843</a> <span class="keywordtype">char</span> *<a class="code" href="util_8h.html#a50">UTIL_rev_addr</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *s)
01844 {
01845   u_int8_t i = 0;        <span class="comment">/* utility */</span>
01846   u_int8_t tmp[4][1];    <span class="comment">/* temporary storage for ip integers */</span>
01847 
01848   u_int16_t len = 0;     <span class="comment">/* length of to be allocated string */</span>
01849 
01850   <span class="keywordtype">char</span> *cp;              <span class="comment">/* copy of passed string */</span>
01851   <span class="keywordtype">char</span> *token;           <span class="comment">/* token for splitting apart ip address */</span>
01852   <span class="keywordtype">char</span> *new_addr;        <span class="comment">/* allocate string for reversed address */</span>
01853 
01854 
01855   <span class="keywordflow">if</span> (s == NULL)
01856   {
01857     <a class="code" href="util_8h.html#a13">xepprintf</a>(<span class="stringliteral">"passed a null string.  Abort!\n"</span>);
01858 
01859     <span class="keywordflow">return</span>(NULL);
01860   }
01861 
01862   len = (strlen(s) + 1);
01863 
01864   <a class="code" href="util_8h.html#a9">xprintf</a>(<span class="stringliteral">"called with: (%s) len: (%i)\n"</span>, s, (len - 1));
01865 
01866   cp    = <a class="code" href="util_8h.html#a8">xstrndup</a>(s, len);
01867   token = strtok(cp, <span class="stringliteral">"."</span>);
01868 
01869   <span class="keywordflow">while</span> ((token != NULL) &amp;&amp; (i &lt;= 3))
01870   {
01871     <a class="code" href="util_8h.html#a10">xvprintf</a>(<span class="stringliteral">"token : (%s)\n"</span>, token);
01872 
01873     tmp[i][0] = atoi(token);
01874     token     = strtok(NULL, <span class="stringliteral">"."</span>);
01875     i++;
01876   }
01877 
01878   <a class="code" href="util_8h.html#a6">xfree</a>(cp);
01879 
01880   <span class="comment">/* + .in-addr.arpa\0 */</span>
01881   new_addr = <a class="code" href="util_8h.html#a4">xmalloc</a>(len + 13);
01882 
01883   snprintf(new_addr, (len + 13), <span class="stringliteral">"%u.%u.%u.%u.in-addr.arpa"</span>,
01884     tmp[3][0], tmp[2][0], tmp[1][0], tmp[0][0]);
01885 
01886   <a class="code" href="util_8h.html#a10">xvprintf</a>(<span class="stringliteral">"leaving function; returning reversed ip: %s\n"</span>, new_addr);
01887 
01888   <span class="keywordflow">return</span>(new_addr);
01889 }
01890 
01891 
01892 <span class="comment">/* UTIL_get_dname</span>
01893 <span class="comment">*</span>
01894 <span class="comment">*  Author: James Couzens &lt;jcouzens@codeshare.ca&gt;</span>
01895 <span class="comment">*</span>
01896 <span class="comment">*  Date:   01/27/04</span>
01897 <span class="comment">*</span>
01898 <span class="comment">*  Desc:</span>
01899 <span class="comment">*          s contains a hostname which is then looked through and split</span>
01900 <span class="comment">*  apart, always leaving one '.' delimiter left so you are left with</span>
01901 <span class="comment">*  domain.tld.  domain.tld is then put into newly allocated memory and</span>
01902 <span class="comment">*  returned to the calling function.  Upon failure, returns NULL.</span>
01903 <span class="comment">*  Calling function is required to free the memory.</span>
01904 <span class="comment">*</span>
01905 <span class="comment">*/</span>
<a name="l01906"></a><a class="code" href="util_8h.html#a51">01906</a> <span class="keywordtype">char</span> *<a class="code" href="util_8h.html#a51">UTIL_get_dname</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *s)
01907 {
01908   u_int8_t i = 0;      <span class="comment">/* how many delimiters in s */</span>
01909 
01910   <span class="keywordtype">char</span> *buf = NULL;    <span class="comment">/* return string to be allocated */</span>
01911 
01912 
01913   <span class="keywordflow">if</span> (s == NULL)
01914   {
01915     <a class="code" href="util_8h.html#a13">xepprintf</a>(<span class="stringliteral">"called with NULL.  Abort!\n"</span>);
01916 
01917     <span class="keywordflow">return</span>(NULL);
01918   }
01919 
01920   <a class="code" href="util_8h.html#a10">xvprintf</a>(<span class="stringliteral">"called with (%s)\n"</span>, s);
01921 
01922   i = <a class="code" href="util_8h.html#a38">UTIL_count_delim</a>(s, <span class="charliteral">'.'</span>);
01923 
01924   <span class="keywordflow">switch</span> (i)
01925   {
01926     <span class="keywordflow">case</span> 0:
01927       <span class="keywordflow">break</span>;
01928     <span class="keywordflow">case</span> 1:
01929       buf = <a class="code" href="util_8h.html#a8">xstrndup</a>(s, (strlen(s) + 1));
01930       <a class="code" href="util_8h.html#a9">xprintf</a>(<span class="stringliteral">"leaving function; returning buffer: (%s)\n"</span>, buf);
01931 
01932       <span class="keywordflow">return</span>(buf);
01933     <span class="keywordflow">default</span>:
01934       buf = <a class="code" href="util_8h.html#a36">UTIL_split_str</a>(s, <span class="charliteral">'.'</span>, (i - 1));
01935       <a class="code" href="util_8h.html#a9">xprintf</a>(<span class="stringliteral">"leaving function; returning buffer: (%s)\n"</span>, buf);
01936 
01937       <span class="keywordflow">return</span>(buf);
01938   }
01939 
01940   <a class="code" href="util_8h.html#a13">xepprintf</a>(<span class="stringliteral">"leaving function; returning NULL\n"</span>);
01941 
01942   <span class="keywordflow">return</span>(NULL);
01943 }
01944 
01945 
01946 <span class="comment">/* UTIL_cidr_cmp</span>
01947 <span class="comment">*</span>
01948 <span class="comment">*  Author: James Couzens &lt;jcouzens@codeshare.ca&gt;</span>
01949 <span class="comment">*</span>
01950 <span class="comment">*  Date:   12/26/03</span>
01951 <span class="comment">*</span>
01952 <span class="comment">*  Desc:</span>
01953 <span class="comment">*          Compares an IP address (connected peer) against another IP</span>
01954 <span class="comment">*  address (found in a policy lookup) using a netmask (also found from</span>
01955 <span class="comment">*  a policy lookup) to see if the peer address is legal within that</span>
01956 <span class="comment">*  netmask.  Returns SPF_TRUE if its valid, SPF_FALSE if not.</span>
01957 <span class="comment">*</span>
01958 <span class="comment">*  Notes:  Write additional comparisons to handle IP6 addresses</span>
01959 <span class="comment">*</span>
01960 <span class="comment">*/</span>
<a name="l01961"></a><a class="code" href="util_8h.html#a52">01961</a> <a class="code" href="spf_8h.html#a35">SPF_BOOL</a> <a class="code" href="util_8h.html#a52">UTIL_cidr_cmp</a>(<span class="keyword">const</span> <a class="code" href="structpolicy__addr__s.html">policy_addr_t</a> *policy_addr, <span class="keyword">const</span> <span class="keyword">struct</span> in_addr
01962   *peer_addr)
01963 {
01964   u_int32_t a;               <span class="comment">/* working buf */</span>
01965   u_int32_t b;               <span class="comment">/* working buf */</span>
01966 
01967   <span class="keywordtype">char</span> *peer_ip  = NULL;     <span class="comment">/* ip address of connected peer */</span>
01968   <span class="keywordtype">char</span> *policy_ip = NULL;    <span class="comment">/* ip address of current SPF policy */</span>
01969 
01970 
01971   <span class="keywordflow">if</span> ((policy_addr-&gt;<a class="code" href="structpolicy__addr__s.html#o2">addr</a>.s_addr &lt;= 0) &amp;&amp; (peer_addr-&gt;s_addr &lt;= 0))
01972   {
01973     <a class="code" href="util_8h.html#a13">xepprintf</a>(<span class="stringliteral">"Passed with NULL chars.  Aborting.\n"</span>);
01974 
01975     <span class="keywordflow">return</span>(<a class="code" href="spf_8h.html#a87a49">SPF_FALSE</a>);
01976   }
01977 
01978   <a class="code" href="util_8h.html#a10">xvprintf</a>(<span class="stringliteral">"POL: %lu PEER: %lu CIDR: %i\n"</span>, policy_addr-&gt;<a class="code" href="structpolicy__addr__s.html#o2">addr</a>.s_addr,
01979     peer_addr-&gt;s_addr, policy_addr-&gt;<a class="code" href="structpolicy__addr__s.html#o1">cidr</a>);
01980 
01981    <span class="comment">/*</span>
01982 <span class="comment">   * Packets come in off the wire in whats called "network byte order"</span>
01983 <span class="comment">   * which does't work very well when trying to compute if one address</span>
01984 <span class="comment">   * is masked by another using a CIDR calculation so the 'ntohl' is </span>
01985 <span class="comment">   * issued on them to change their byte order</span>
01986 <span class="comment">  */</span>
01987   a = ntohl(peer_addr-&gt;s_addr);
01988   b = ntohl(policy_addr-&gt;<a class="code" href="structpolicy__addr__s.html#o2">addr</a>.s_addr);
01989 
01990   <span class="keywordflow">if</span> (policy_addr-&gt;<a class="code" href="structpolicy__addr__s.html#o1">cidr</a> != 32)
01991   {
01992     <span class="keywordflow">if</span> ((a&amp;(~0U&lt;&lt;(32-policy_addr-&gt;<a class="code" href="structpolicy__addr__s.html#o1">cidr</a>))) != (b&amp;(~0U&lt;&lt;(32-policy_addr-&gt;<a class="code" href="structpolicy__addr__s.html#o1">cidr</a>))))
01993     {
01994       <span class="keywordflow">return</span>(<a class="code" href="spf_8h.html#a87a49">SPF_FALSE</a>);
01995     }
01996   }
01997   <span class="keywordflow">else</span>
01998   {
01999     <span class="keywordflow">if</span> (peer_addr-&gt;s_addr != policy_addr-&gt;<a class="code" href="structpolicy__addr__s.html#o2">addr</a>.s_addr)
02000     {
02001       <a class="code" href="util_8h.html#a10">xvprintf</a>(<span class="stringliteral">"%lu and %lu using 32 cidr do not match\n"</span>,
02002         peer_addr-&gt;s_addr, policy_addr-&gt;<a class="code" href="structpolicy__addr__s.html#o2">addr</a>.s_addr);
02003 
02004       <span class="keywordflow">return</span>(<a class="code" href="spf_8h.html#a87a49">SPF_FALSE</a>);
02005     }
02006   }
02007 
02008   <span class="comment">/* these are done here just for debugger remove later */</span>
02009   peer_ip   = <a class="code" href="util_8h.html#a8">xstrndup</a>(inet_ntoa(*peer_addr), <a class="code" href="spf_8h.html#a11">SPF_MAX_IP_ADDR</a>);
02010   policy_ip = <a class="code" href="util_8h.html#a8">xstrndup</a>(inet_ntoa(policy_addr-&gt;<a class="code" href="structpolicy__addr__s.html#o2">addr</a>), <a class="code" href="spf_8h.html#a11">SPF_MAX_IP_ADDR</a>);
02011 
02012   <a class="code" href="util_8h.html#a10">xvprintf</a>(<span class="stringliteral">"Peer: (%s) matches address %s with network %i\n"</span>,
02013     peer_ip, policy_ip, policy_addr-&gt;<a class="code" href="structpolicy__addr__s.html#o1">cidr</a>);
02014 
02015   <a class="code" href="util_8h.html#a6">xfree</a>(peer_ip);
02016   <a class="code" href="util_8h.html#a6">xfree</a>(policy_ip);
02017 
02018   <span class="keywordflow">return</span>(<a class="code" href="spf_8h.html#a87a50">SPF_TRUE</a>);
02019 }
02020 
02021 
02022 <span class="comment">/* UTIL_validate_ptr</span>
02023 <span class="comment">*</span>
02024 <span class="comment">*  Author: James Couzens &lt;jcouzens@codeshare.ca&gt;</span>
02025 <span class="comment">*</span>
02026 <span class="comment">*  Date:   12/26/03</span>
02027 <span class="comment">*</span>
02028 <span class="comment">*  Desc:</span>
02029 <span class="comment">*          Using the ip address found in the passed peer_info structure,</span>
02030 <span class="comment">*  a PTR lookup is made and if a record exists then this is record is compared</span>
02031 <span class="comment">*  against the hostname the client wishes to send mail from.  If the tld matches</span>
02032 <span class="comment">*  the tld found during this query, this would be a 'valdiated' PTR.  If a match</span>
02033 <span class="comment">*  can not be found we return SPF_FALSE.  If a match is made we return SPF_TRUE.</span>
02034 <span class="comment">*</span>
02035 <span class="comment">*  Notes:  Write additional comparisons to handle IP6 addresses</span>
02036 <span class="comment">*</span>
02037 <span class="comment">*/</span>
<a name="l02038"></a><a class="code" href="util_8h.html#a53">02038</a> <a class="code" href="spf_8h.html#a35">SPF_BOOL</a> <a class="code" href="util_8h.html#a53">UTIL_validate_ptr</a>(<a class="code" href="structpeer__info__s.html">peer_info_t</a> *p)
02039 {
02040   <span class="keywordtype">char</span> *ptr_addr;    <span class="comment">/* reversed address into PTR format */</span>
02041   <span class="keywordtype">char</span> *tmp_ptr;     <span class="comment">/* utility pointer */</span>
02042 
02043 
02044   <span class="keywordflow">if</span> (!p)
02045   {
02046     <a class="code" href="util_8h.html#a13">xepprintf</a>(<span class="stringliteral">"called with an invalid peer info structure!\n"</span>);
02047 
02048     <span class="keywordflow">return</span>(<a class="code" href="spf_8h.html#a87a49">SPF_FALSE</a>);
02049   }
02050 
02051   <span class="comment">/* reverse of the address in peer_info */</span>
02052   ptr_addr = <a class="code" href="util_8h.html#a50">UTIL_rev_addr</a>(p-&gt;<a class="code" href="structpeer__info__s.html#o17">r_ip</a>);
02053   <a class="code" href="util_8h.html#a10">xvprintf</a>(<span class="stringliteral">"[address: %s]\n"</span>, ptr_addr);
02054 
02055   tmp_ptr = <a class="code" href="util_8h.html#a8">xstrndup</a>(p-&gt;<a class="code" href="structpeer__info__s.html#o15">current_domain</a>, <a class="code" href="spf_8h.html#a14">SPF_MAX_HNAME</a>);
02056 
02057   <span class="keywordflow">if</span> (<a class="code" href="dns_8h.html#a8">DNS_query</a>(p, ptr_addr, T_PTR, tmp_ptr) != (<span class="keywordtype">char</span> *)<a class="code" href="spf_8h.html#a87a50">SPF_TRUE</a>)
02058   {
02059     <a class="code" href="util_8h.html#a10">xvprintf</a>(<span class="stringliteral">"PTR lookup failed: (%s) (%s)\n"</span>, p-&gt;<a class="code" href="structpeer__info__s.html#o7">rs</a>, p-&gt;<a class="code" href="structpeer__info__s.html#o24">error</a>);
02060 
02061     <a class="code" href="util_8h.html#a6">xfree</a>(ptr_addr);
02062     <a class="code" href="util_8h.html#a6">xfree</a>(tmp_ptr);
02063 
02064     <span class="keywordflow">return</span>(<a class="code" href="spf_8h.html#a87a49">SPF_FALSE</a>);
02065   }
02066 
02067   <a class="code" href="util_8h.html#a10">xvprintf</a>(<span class="stringliteral">"Peer (%s) successfully validated hostname (%s)\n"</span>,
02068     p-&gt;<a class="code" href="structpeer__info__s.html#o17">r_ip</a>, p-&gt;<a class="code" href="structpeer__info__s.html#o18">r_vhname</a>);
02069 
02070   <a class="code" href="util_8h.html#a6">xfree</a>(ptr_addr);
02071   <a class="code" href="util_8h.html#a6">xfree</a>(tmp_ptr);
02072 
02073   <span class="keywordflow">return</span>(<a class="code" href="spf_8h.html#a87a50">SPF_TRUE</a>);
02074 }
02075 
02076 
02077 <span class="comment">/* UTIL_validate_hostname</span>
02078 <span class="comment">*</span>
02079 <span class="comment">*  Author: James Couzens &lt;jcouzens@codeshare.ca&gt;</span>
02080 <span class="comment">*</span>
02081 <span class="comment">*  Date:   01/08/04</span>
02082 <span class="comment">*</span>
02083 <span class="comment">*  Desc:</span>
02084 <span class="comment">*          s contains a hostname which is then looked up to find any</span>
02085 <span class="comment">*  of the returned ip addresses SPF_PASS the remote peers.  On a successful</span>
02086 <span class="comment">*  SPF_PASS returns SPF_TRUE.  When no SPF_PASS is made, returns SPF_FALSE.</span>
02087 <span class="comment">*</span>
02088 <span class="comment">*  Note:</span>
02089 <span class="comment">*          We need to define and set a limit on the number of recursive</span>
02090 <span class="comment">*  lookups.  I recall seeing this in the RFC, we should discuss this.</span>
02091 <span class="comment">*</span>
02092 <span class="comment">*  Date:  08/28/04 by James</span>
02093 <span class="comment">*</span>
02094 <span class="comment">*  Desc:</span>
02095 <span class="comment">*          Added buffer for reentrant gethostbyname wrapper</span>
02096 <span class="comment">*  and change gethostbyname calls to use the MACRO wrapper</span>
02097 <span class="comment">*  xgethostbyname()</span>
02098 <span class="comment">*</span>
02099 <span class="comment">*/</span>
<a name="l02100"></a><a class="code" href="util_8h.html#a54">02100</a> <a class="code" href="spf_8h.html#a35">SPF_BOOL</a> <a class="code" href="util_8h.html#a54">UTIL_validate_hostname</a>(<a class="code" href="structpeer__info__s.html">peer_info_t</a> *p, <span class="keyword">const</span> <span class="keywordtype">char</span> *s, <span class="keyword">const</span> int8_t cidr)
02101 {
02102   <span class="keywordtype">int</span> tmp_errno = 0;                    <span class="comment">/* temporary errno placeholder */</span>
02103 
02104   <span class="keywordtype">char</span> **a     = NULL;                  <span class="comment">/* work ptr for list recursion */</span>
02105 
02106   <span class="keywordtype">char</span> *ip     = NULL;                  <span class="comment">/* ip address */</span>
02107   <span class="keywordtype">char</span> *gbuf   = NULL;                  <span class="comment">/* reentrant buffer for gethostbyname_r */</span>
02108 
02109   <span class="keyword">struct </span>in_addr addr;                  <span class="comment">/* connected peer's address */</span>
02110   <span class="keyword">struct </span>hostent *hp = NULL;            <span class="comment">/* hostent structure */</span>
02111   <span class="keyword">struct </span>hostent tmp_hp;                <span class="comment">/* temporary hostent structure */</span>
02112 
02113   <a class="code" href="structpolicy__addr__s.html">policy_addr_t</a> policy_addr;            <span class="comment">/* used for cidr calculations */</span>
02114 
02115 
02116   <span class="keywordflow">if</span> (s == NULL)
02117   {
02118     <a class="code" href="util_8h.html#a13">xepprintf</a>(<span class="stringliteral">"passed a NULL string.\n"</span>);
02119 
02120     <span class="keywordflow">return</span>(<a class="code" href="spf_8h.html#a87a49">SPF_FALSE</a>);
02121   }
02122 
02123   <a class="code" href="util_8h.html#a10">xvprintf</a>(<span class="stringliteral">"called with: (%lu) and (%s)\n"</span>, p-&gt;<a class="code" href="structpeer__info__s.html#o17">r_ip</a>, s);
02124 
02125   gbuf = <a class="code" href="util_8h.html#a4">xmalloc</a>(<a class="code" href="util_8h.html#a2">SPF_MAX_GHBNR_DBUF</a>);
02126 
02127   <span class="keywordflow">if</span> ((hp = <a class="code" href="dns_8h.html#a4">xgethostbyname</a>(s, &amp;tmp_hp, gbuf, <a class="code" href="util_8h.html#a2">SPF_MAX_GHBNR_DBUF</a>,
02128     &amp;tmp_errno)) != NULL)
02129   {
02130     <span class="comment">/* for each hostname in the list, perform CIDR checks */</span>
02131     <span class="keywordflow">for</span> (a = hp-&gt;h_addr_list; *a; a++)
02132     {
02133       memcpy(&amp;addr.s_addr, *a, <a class="code" href="util_8h.html#a3">SIZEOF</a>(<span class="keyword">struct</span> in_addr));
02134       ip = <a class="code" href="util_8h.html#a8">xstrndup</a>(inet_ntoa(addr), <a class="code" href="spf_8h.html#a11">SPF_MAX_IP_ADDR</a>);
02135 
02136       <a class="code" href="util_8h.html#a10">xvprintf</a>(<span class="stringliteral">"CLI: %s (%lu) SRV: %s (%lu)\n"</span>, ip, addr.s_addr,
02137         p-&gt;<a class="code" href="structpeer__info__s.html#o17">r_ip</a>, p-&gt;<a class="code" href="structpeer__info__s.html#o26">addr</a>.s_addr);
02138 
02139       <span class="keywordflow">if</span> (cidr == 32)
02140       {
02141         <span class="keywordflow">if</span> (((<span class="keyword">struct </span>in_addr *)(*a))-&gt;s_addr == p-&gt;<a class="code" href="structpeer__info__s.html#o26">addr</a>.s_addr)
02142         {
02143           <a class="code" href="util_8h.html#a10">xvprintf</a>(<span class="stringliteral">"%s (%lu) matches %s (%lu)\n"</span>, ip,
02144             ((<span class="keyword">struct</span> in_addr *)(*a))-&gt;s_addr, p-&gt;<a class="code" href="structpeer__info__s.html#o17">r_ip</a>, p-&gt;<a class="code" href="structpeer__info__s.html#o26">addr</a>.s_addr);
02145 
02146           <a class="code" href="util_8h.html#a47">UTIL_assoc_prefix</a>(p, <a class="code" href="spf_8h.html#a88a51">SPF_PASS</a>, NULL);
02147 
02148           <a class="code" href="util_8h.html#a6">xfree</a>(ip);
02149           <a class="code" href="util_8h.html#a6">xfree</a>(gbuf);
02150 
02151           <a class="code" href="dns_8h.html#a5">xgethostbyname_free</a>();    <span class="comment">/* unlock mutex */</span>
02152 
02153           <span class="keywordflow">return</span>(<a class="code" href="spf_8h.html#a87a50">SPF_TRUE</a>);
02154         }
02155       }
02156       <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((cidr &lt; 32) &amp;&amp; (cidr &gt;= 8))
02157       {
02158         <span class="comment">/* convert from character string to dotted quad notation */</span>
02159         <span class="keywordflow">if</span> ((inet_pton(AF_INET, ip, &amp;policy_addr.addr)) == 0)
02160         {
02161           <a class="code" href="util_8h.html#a13">xepprintf</a>(<span class="stringliteral">"Unable to execute inet_pton()\n"</span>);
02162         }
02163 
02164         policy_addr.cidr = cidr;
02165 
02166         <a class="code" href="util_8h.html#a10">xvprintf</a>(<span class="stringliteral">"Address: %lu with CIDR %i\n"</span>,
02167           policy_addr.addr.s_addr, policy_addr.cidr);
02168 
02169         <span class="comment">/* perform CIDR comparison of 'policy_addr' vs 'p-&gt;addr' */</span> 
02170         <span class="keywordflow">if</span> ((<a class="code" href="util_8h.html#a52">UTIL_cidr_cmp</a>(&amp;policy_addr, &amp;p-&gt;<a class="code" href="structpeer__info__s.html#o26">addr</a>)) == <a class="code" href="spf_8h.html#a87a50">SPF_TRUE</a>)
02171         {
02172           <a class="code" href="util_8h.html#a10">xvprintf</a>(<span class="stringliteral">"(%lu) matches (%lu) with CIDR %u\n"</span>,
02173             policy_addr.addr.s_addr, p-&gt;<a class="code" href="structpeer__info__s.html#o26">addr</a>.s_addr, cidr);
02174 
02175           <span class="comment">/* associate an SPF prefix (-,+,~,?) with this check */</span>
02176           <a class="code" href="util_8h.html#a47">UTIL_assoc_prefix</a>(p, <a class="code" href="spf_8h.html#a88a51">SPF_PASS</a>, NULL);
02177 
02178           <a class="code" href="util_8h.html#a6">xfree</a>(ip);
02179           <a class="code" href="util_8h.html#a6">xfree</a>(gbuf);
02180 
02181           <a class="code" href="dns_8h.html#a5">xgethostbyname_free</a>();
02182 
02183           <span class="keywordflow">return</span>(<a class="code" href="spf_8h.html#a87a50">SPF_TRUE</a>);
02184         }
02185       } <span class="comment">/* else if */</span>
02186 
02187       <a class="code" href="util_8h.html#a6">xfree</a>(ip);
02188 
02189     } <span class="comment">/* for */</span>
02190 
02191     <span class="comment">/* for each alias (CNAME) perform a CIDR check */</span>
02192     <span class="keywordflow">for</span> (a = hp-&gt;h_aliases; *a; a++)
02193     {
02194       memcpy(&amp;addr.s_addr, *a, <a class="code" href="util_8h.html#a3">SIZEOF</a>(<span class="keyword">struct</span> in_addr));
02195       ip = <a class="code" href="util_8h.html#a8">xstrndup</a>(inet_ntoa(addr), <a class="code" href="spf_8h.html#a11">SPF_MAX_IP_ADDR</a>);
02196 
02197       <a class="code" href="util_8h.html#a10">xvprintf</a>(<span class="stringliteral">"client: %s (%lu); policy: %s (%lu)\n"</span>,
02198         ip, addr.s_addr, p-&gt;<a class="code" href="structpeer__info__s.html#o17">r_ip</a>, p-&gt;<a class="code" href="structpeer__info__s.html#o26">addr</a>.s_addr);
02199 
02200       <span class="keywordflow">if</span> (cidr == 32)
02201       {
02202         <span class="keywordflow">if</span> (((<span class="keyword">struct </span>in_addr *)(*a))-&gt;s_addr == p-&gt;<a class="code" href="structpeer__info__s.html#o26">addr</a>.s_addr)
02203         {
02204           <a class="code" href="util_8h.html#a10">xvprintf</a>(<span class="stringliteral">"IN A: client: %s (%lu) matches policy: %s (%lu)\n"</span>,
02205             ip, ((<span class="keyword">struct</span> in_addr *)(*a))-&gt;s_addr, p-&gt;<a class="code" href="structpeer__info__s.html#o17">r_ip</a>, p-&gt;<a class="code" href="structpeer__info__s.html#o26">addr</a>.s_addr);
02206 
02207           <a class="code" href="util_8h.html#a6">xfree</a>(ip);
02208           <a class="code" href="util_8h.html#a6">xfree</a>(gbuf);
02209 
02210           <span class="keywordflow">return</span>(<a class="code" href="spf_8h.html#a87a50">SPF_TRUE</a>);
02211         }
02212       }
02213       <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((cidr &lt; 32) &amp;&amp; (cidr &gt;= 8))
02214       {
02215         <span class="keywordflow">if</span> (inet_pton(AF_INET, ip, &amp;policy_addr.addr) == 0)
02216         {
02217           <a class="code" href="util_8h.html#a13">xepprintf</a>(<span class="stringliteral">"Unable to execute inet_pton()\n"</span>);
02218         }
02219 
02220         policy_addr.cidr = cidr;
02221 
02222         <span class="keywordflow">if</span> (<a class="code" href="util_8h.html#a52">UTIL_cidr_cmp</a>(&amp;policy_addr, &amp;p-&gt;<a class="code" href="structpeer__info__s.html#o26">addr</a>) == <a class="code" href="spf_8h.html#a87a50">SPF_TRUE</a>)
02223         {
02224           <a class="code" href="util_8h.html#a10">xvprintf</a>(<span class="stringliteral">"client: (%lu) matches policy (%lu) with CIDR %u\n"</span>,
02225             policy_addr.addr.s_addr, p-&gt;<a class="code" href="structpeer__info__s.html#o26">addr</a>.s_addr, cidr);
02226 
02227           <a class="code" href="util_8h.html#a6">xfree</a>(ip);
02228           <a class="code" href="util_8h.html#a6">xfree</a>(gbuf);
02229 
02230           <span class="comment">/* associate an SPF prefix (-,+,~,?) with this check */</span>
02231           <a class="code" href="util_8h.html#a47">UTIL_assoc_prefix</a>(p, <a class="code" href="spf_8h.html#a88a51">SPF_PASS</a>, NULL);
02232 
02233           <span class="keywordflow">return</span>(<a class="code" href="spf_8h.html#a87a50">SPF_TRUE</a>);
02234         }
02235       } <span class="comment">/* else */</span>
02236       
02237       <a class="code" href="util_8h.html#a6">xfree</a>(ip);
02238       
02239     } <span class="comment">/* for */</span>
02240   } <span class="comment">/* if .. xgethostbyname() */</span>
02241   <span class="keywordflow">else</span>
02242   {
02243     <a class="code" href="util_8h.html#a10">xvprintf</a>(<span class="stringliteral">"No address associated with hostname (%s); Reason: %s\n"</span>,
02244       s, hstrerror(tmp_errno));
02245   }
02246 
02247   <a class="code" href="util_8h.html#a6">xfree</a>(gbuf);
02248 
02249   <a class="code" href="dns_8h.html#a5">xgethostbyname_free</a>();
02250 
02251   <a class="code" href="util_8h.html#a11">xpprintf</a>(<span class="stringliteral">"leaving function; returning SPF_FALSE\n"</span>);
02252 
02253   <span class="keywordflow">return</span>(<a class="code" href="spf_8h.html#a87a49">SPF_FALSE</a>);
02254 }
02255 
02256 
02257 <span class="comment">/* UTIL_url_encode</span>
02258 <span class="comment">*</span>
02259 <span class="comment">*  Author: Sean Comeau &lt;scomeau@obscurity.org&gt;</span>
02260 <span class="comment">*</span>
02261 <span class="comment">*  Date:   01/06/04</span>
02262 <span class="comment">*</span>
02263 <span class="comment">*  Desc:</span>
02264 <span class="comment">*          "URL-Encode" characters that are "unsafe" or "prohibited" from a URL.</span>
02265 <span class="comment">*  Upon success returns a pointer to a newly allocated memory containing the</span>
02266 <span class="comment">*  encoded string.  Upon failure returns a NULL pointer.  Failure</span>
02267 <span class="comment">*  indicates either a failure to allocate new memory, or the passed string</span>
02268 <span class="comment">*  did not contain any questionable characters and hence did not require</span>
02269 <span class="comment">*  encoding.</span>
02270 <span class="comment">*</span>
02271 <span class="comment">*/</span>
<a name="l02272"></a><a class="code" href="util_8h.html#a55">02272</a> <span class="keywordtype">char</span> *<a class="code" href="util_8h.html#a55">UTIL_url_encode</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *s)
02273 {
02274   <span class="keywordtype">int</span> len;          <span class="comment">/* length of passed string * 3*/</span>
02275 
02276   <span class="keywordtype">char</span> *<span class="keyword">new</span>;        <span class="comment">/* newly allocated memory */</span>
02277   <span class="keywordtype">char</span> *encoded;    <span class="comment">/* encoded return string */</span>
02278 
02279 
02280   <span class="keywordflow">if</span> (s != NULL)
02281   {
02282      <span class="comment">/*</span>
02283 <span class="comment">     * length of the string times 3 is the maximum possible size a</span>
02284 <span class="comment">     * URL encoded string should ever be able to expand to.</span>
02285 <span class="comment">    */</span>
02286     len = (strlen(s) * 3);
02287   }
02288   <span class="keywordflow">else</span>
02289   {
02290     <a class="code" href="util_8h.html#a13">xepprintf</a>(<span class="stringliteral">"passed a NULL string.  Abort!\n"</span>);
02291 
02292     <span class="keywordflow">return</span>(NULL);
02293   }
02294 
02295   encoded = <span class="keyword">new</span> = <a class="code" href="util_8h.html#a4">xmalloc</a>(len);
02296 
02297   <span class="keywordflow">while</span> (*s != <span class="charliteral">'\0'</span>)
02298   {
02299     <span class="keywordflow">if</span> (<a class="code" href="util_8h.html#a17">urlchr_test</a>(*s) == 0)
02300     {
02301       *<span class="keyword">new</span>++ = *s++;
02302     }
02303     <span class="keywordflow">else</span>
02304     {
02305       <span class="comment">/* this obviously NULL terminates, do we want this? */</span>
02306       snprintf(<span class="keyword">new</span>, 4, <span class="stringliteral">"%%%x"</span>, *s);
02307       <span class="keyword">new</span> += 3;
02308       s++;
02309     }
02310   }
02311 
02312   *<span class="keyword">new</span>++ = <span class="charliteral">'\0'</span>;
02313   <a class="code" href="util_8h.html#a10">xvprintf</a>(<span class="stringliteral">"leaving function; returning (%s)\n"</span>, encoded);
02314 
02315   <span class="keywordflow">return</span>(encoded);
02316 }
02317 
02318 
02319 <span class="comment">/* UTIL_reverse</span>
02320 <span class="comment">*</span>
02321 <span class="comment">*  Author: James Couzens &lt;jcouzens@codeshare.ca&gt;</span>
02322 <span class="comment">*</span>
02323 <span class="comment">*  Date:   01/06/04</span>
02324 <span class="comment">*</span>
02325 <span class="comment">*  Desc:</span>
02326 <span class="comment">*          Takes a string and rebuilds it in reverse order using the</span>
02327 <span class="comment">*  supplied delimiter.  The string will always be rebuilt using a</span>
02328 <span class="comment">*  '.' char as per the RFC.</span>
02329 <span class="comment">*</span>
02330 <span class="comment">*/</span>
<a name="l02331"></a><a class="code" href="util_8h.html#a56">02331</a> <span class="keywordtype">char</span> *<a class="code" href="util_8h.html#a56">UTIL_reverse</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *s, <span class="keyword">const</span> <span class="keywordtype">char</span> delim)
02332 {
02333   size_t len;                     <span class="comment">/* length of s */</span>
02334 
02335   <span class="keywordtype">char</span> *buf;                      <span class="comment">/* return buffer */</span>
02336   <span class="keywordtype">char</span> *p;                        <span class="comment">/* working pointer */</span>
02337   <span class="keywordtype">char</span> *cp;                       <span class="comment">/* working pointer */</span>
02338   <span class="keywordtype">char</span> *c;                        <span class="comment">/* working pointer */</span>
02339 
02340   <a class="code" href="structsplit__str__s.html">split_str_t</a> *master;            <span class="comment">/* list pointers */</span>
02341 
02342   <a class="code" href="structsplit__str__node__s.html">split_str_node_t</a> *c_node;       <span class="comment">/* c_node node */</span>
02343   <a class="code" href="structsplit__str__node__s.html">split_str_node_t</a> *kill_node;    <span class="comment">/* temp node used in destruction */</span>
02344 
02345 
02346   <span class="keywordflow">if</span> (s == NULL)
02347   {
02348     <a class="code" href="util_8h.html#a13">xepprintf</a>(<span class="stringliteral">"passed a NULL string.  Abort!\n"</span>);
02349 
02350     <span class="keywordflow">return</span>(NULL);
02351   }
02352 
02353   <a class="code" href="util_8h.html#a10">xvprintf</a>(<span class="stringliteral">"called with (%s) and delim (%c)\n"</span>, s, delim);
02354 
02355   len = strlen(s);
02356   cp  = c = <a class="code" href="util_8h.html#a8">xstrndup</a>(s, (len + 1));
02357 
02358   master           = <a class="code" href="util_8h.html#a4">xmalloc</a>(<a class="code" href="util_8h.html#a3">SIZEOF</a>(<a class="code" href="structsplit__str__s.html">split_str_t</a>));
02359   master-&gt;<a class="code" href="structsplit__str__s.html#o0">head</a>     = NULL;
02360   master-&gt;<a class="code" href="structsplit__str__s.html#o1">tail</a>     = NULL;
02361   master-&gt;<a class="code" href="structsplit__str__s.html#o2">elements</a> = 0;
02362 
02363   <span class="comment">/* </span>
02364 <span class="comment">   *  Comment: James Couzens &lt;jcouzens@codeshare.ca&gt;</span>
02365 <span class="comment">   *</span>
02366 <span class="comment">   *  Date: 01/22/04</span>
02367 <span class="comment">   *</span>
02368 <span class="comment">   * we do not want the trailing delim so the first iteration of this</span>
02369 <span class="comment">   * loop we call UTIL_addnode with 0, which tells it not to allocate</span>
02370 <span class="comment">   * the extra byte for the trailing delimiter.  This is done only</span>
02371 <span class="comment">   * when passed an IP address, and this is because when reversing we</span>
02372 <span class="comment">   * want: 1.0.168.192. and not .1.0.168.192</span>
02373 <span class="comment">   *</span>
02374 <span class="comment">  */</span>
02375   
02376   len++;
02377   buf = <a class="code" href="util_8h.html#a4">xmalloc</a>(len);
02378   <span class="keywordflow">while</span> ((p = strrchr(cp, delim)) != NULL)
02379   {
02380     p++;   <span class="comment">/* remove period */</span>
02381     <a class="code" href="util_8h.html#a57">UTIL_addnode</a>(master, p, <a class="code" href="spf_8h.html#a87a50">SPF_TRUE</a>);
02382     p--;   <span class="comment">/* bring it back */</span>
02383     *p = <span class="charliteral">'\0'</span>;
02384   }
02385 
02386   <a class="code" href="util_8h.html#a57">UTIL_addnode</a>(master, cp, <a class="code" href="spf_8h.html#a87a49">SPF_FALSE</a>);
02387 
02388   c_node = master-&gt;<a class="code" href="structsplit__str__s.html#o0">head</a>;
02389   <span class="keywordflow">while</span> ((kill_node = c_node) != NULL)
02390   {
02391     strncat(buf, kill_node-&gt;<a class="code" href="structsplit__str__node__s.html#o1">s</a>, kill_node-&gt;<a class="code" href="structsplit__str__node__s.html#o0">len</a>);
02392     <a class="code" href="util_8h.html#a6">xfree</a>(kill_node-&gt;<a class="code" href="structsplit__str__node__s.html#o1">s</a>);
02393     c_node = c_node-&gt;<a class="code" href="structsplit__str__node__s.html#o2">next</a>;
02394     <a class="code" href="util_8h.html#a6">xfree</a>(kill_node);
02395   }
02396 
02397   <a class="code" href="util_8h.html#a6">xfree</a>(cp);
02398   <a class="code" href="util_8h.html#a6">xfree</a>(master);
02399 
02400   <a class="code" href="util_8h.html#a10">xvprintf</a>(<span class="stringliteral">"leaving function; returning (%s)\n"</span>, buf);
02401 
02402   <span class="keywordflow">return</span>(buf);
02403 }
02404 
02405 
02406 <span class="comment">/*  UTIL_addnode</span>
02407 <span class="comment">*</span>
02408 <span class="comment">*  Author: James Couzens &lt;jcouzens@codeshare.ca&gt;</span>
02409 <span class="comment">*</span>
02410 <span class="comment">*  Date:   01/18/04</span>
02411 <span class="comment">*</span>
02412 <span class="comment">*  Desc:</span>
02413 <span class="comment">*         Allocates memory for a new node and slaps it on the end of</span>
02414 <span class="comment">*  of the passed list.  In the process of doing so, when it comes to</span>
02415 <span class="comment">*  the last element in the list, which is indicated by the SPF_BOOL</span>
02416 <span class="comment">*  that is passed, a final '.' is either appended (SPF_TRUE) or not</span>
02417 <span class="comment">*  (SPF_FALSE).  Function returns SPF_TRUE upon success, and SPF_FALSE upon</span>
02418 <span class="comment">*  failure.</span>
02419 <span class="comment">*</span>
02420 <span class="comment">*/</span>
<a name="l02421"></a><a class="code" href="util_8h.html#a57">02421</a> <a class="code" href="spf_8h.html#a35">SPF_BOOL</a> <a class="code" href="util_8h.html#a57">UTIL_addnode</a>(<a class="code" href="structsplit__str__s.html">split_str_t</a> *master, <span class="keyword">const</span> <span class="keywordtype">char</span> *s, <a class="code" href="spf_8h.html#a35">SPF_BOOL</a> last)
02422 {
02423   size_t len;                     <span class="comment">/* length of s */</span>
02424 
02425   <a class="code" href="structsplit__str__node__s.html">split_str_node_t</a> *c_node;       <span class="comment">/* c_node working node */</span>
02426   <a class="code" href="structsplit__str__node__s.html">split_str_node_t</a> *new_node;     <span class="comment">/* newly allocated node */</span>
02427   <a class="code" href="structsplit__str__node__s.html">split_str_node_t</a> *prev_node;    <span class="comment">/* previous working node */</span>
02428 
02429 
02430   <span class="keywordflow">if</span> (!s || (s == NULL))
02431   {
02432     <a class="code" href="util_8h.html#a13">xepprintf</a>(<span class="stringliteral">"passed a NULL string.  Abort!\n"</span>);
02433 
02434     <span class="keywordflow">return</span>(<a class="code" href="spf_8h.html#a87a49">SPF_FALSE</a>);
02435   }
02436 
02437   <a class="code" href="util_8h.html#a10">xvprintf</a>(<span class="stringliteral">"called with string: (%s); boolean: (%s)\n"</span>, s, 
02438     last ? <span class="stringliteral">"FALSE"</span> : <span class="stringliteral">"TRUE"</span>);
02439  
02440   len = strlen(s);
02441 
02442   <span class="keywordflow">if</span> (last == <a class="code" href="spf_8h.html#a87a50">SPF_TRUE</a>)
02443   {
02444     len += 2;
02445   }
02446   <span class="keywordflow">else</span>
02447   {
02448     len++;
02449   }
02450 
02451   <span class="comment">/* create new node */</span>
02452   new_node = <a class="code" href="util_8h.html#a4">xmalloc</a>(<a class="code" href="util_8h.html#a3">SIZEOF</a>(<a class="code" href="structsplit__str__node__s.html">split_str_node_t</a>));
02453 
02454   <span class="comment">/* set the new nodes next value NULL, and store s */</span>
02455   new_node-&gt;<a class="code" href="structsplit__str__node__s.html#o2">next</a> = NULL;
02456 
02457   new_node-&gt;<a class="code" href="structsplit__str__node__s.html#o1">s</a> = <a class="code" href="util_8h.html#a4">xmalloc</a>(len);
02458 
02459    <span class="comment">/*</span>
02460 <span class="comment">   *  Comment: James Couzens &lt;jcouzens@codeshare.ca&gt;</span>
02461 <span class="comment">   *</span>
02462 <span class="comment">   *  Date: 01/22/04</span>
02463 <span class="comment">   *</span>
02464 <span class="comment">   * section 7.1 (Macro definitions) of the RFC v02.9.5 indicates that we must</span>
02465 <span class="comment">   * always rebuild the macro using the delimiter '.' and not the passed</span>
02466 <span class="comment">   * delimiting character.</span>
02467 <span class="comment">   *</span>
02468 <span class="comment">  */</span>
02469   snprintf(new_node-&gt;<a class="code" href="structsplit__str__node__s.html#o1">s</a>, len, <span class="stringliteral">"%s%c"</span>, s, last ? <span class="charliteral">'.'</span> : <span class="charliteral">'\0'</span>);
02470   new_node-&gt;<a class="code" href="structsplit__str__node__s.html#o0">len</a> = (len - 1); <span class="comment">/* don't count \0 */</span>
02471 
02472   prev_node = NULL;
02473   c_node    = master-&gt;<a class="code" href="structsplit__str__s.html#o0">head</a>;
02474 
02475   <span class="comment">/* reorder the list with the NEW element on the end */</span>
02476   <span class="keywordflow">while</span> (c_node != NULL)
02477   {
02478     prev_node = c_node;
02479     c_node    = c_node-&gt;<a class="code" href="structsplit__str__node__s.html#o2">next</a>;
02480   }
02481 
02482   <span class="keywordflow">if</span> (prev_node != NULL)
02483   {
02484     new_node-&gt;<a class="code" href="structsplit__str__node__s.html#o2">next</a>  = prev_node-&gt;<a class="code" href="structsplit__str__node__s.html#o2">next</a>;
02485     prev_node-&gt;<a class="code" href="structsplit__str__node__s.html#o2">next</a> = new_node;
02486   }
02487   <span class="keywordflow">else</span>
02488   {
02489     master-&gt;<a class="code" href="structsplit__str__s.html#o0">head</a> = new_node;
02490   }
02491 
02492   master-&gt;<a class="code" href="structsplit__str__s.html#o1">tail</a> = new_node;
02493   master-&gt;<a class="code" href="structsplit__str__s.html#o2">elements</a>++;
02494 
02495   <a class="code" href="util_8h.html#a11">xpprintf</a>(<span class="stringliteral">"leaving function; returning SPF_TRUE\n"</span>);
02496 
02497   <span class="keywordflow">return</span>(<a class="code" href="spf_8h.html#a87a50">SPF_TRUE</a>);
02498 }
02499 
02500 
02501 <span class="comment">/* _UTIL_pthread_mutex</span>
02502 <span class="comment">*</span>
02503 <span class="comment">*  Author: James Couzens &lt;jcouzens@codeshare.ca&gt;</span>
02504 <span class="comment">*</span>
02505 <span class="comment">*  Date:   09/08/04</span>
02506 <span class="comment">*</span>
02507 <span class="comment">*  Desc:</span>
02508 <span class="comment">*         Locks or unlocks the passed mutex based on the additional value</span>
02509 <span class="comment">*  which is and enumerattion (SPF_BOOL)</span>
02510 <span class="comment">*</span>
02511 <span class="comment">*/</span>
<a name="l02512"></a><a class="code" href="util_8h.html#a58">02512</a> <span class="keywordtype">void</span> <a class="code" href="util_8h.html#a58">_UTIL_pthread_mutex</a>(<span class="keywordtype">void</span> *mutex, <a class="code" href="spf_8h.html#a35">SPF_BOOL</a> action)
02513 {
02514 
02515 <span class="preprocessor">#ifdef _WITH_PTHREADS</span>
02516 <span class="preprocessor"></span>
02517   <span class="keywordflow">switch</span> (action)
02518   {
02519     <span class="keywordflow">case</span> <a class="code" href="spf_8h.html#a87a50">SPF_TRUE</a>:
02520       pthread_mutex_lock((pthread_mutex_t *)mutex);
02521       <span class="keywordflow">return</span>;
02522 
02523     <span class="keywordflow">case</span> <a class="code" href="spf_8h.html#a87a49">SPF_FALSE</a>:
02524       pthread_mutex_unlock((pthread_mutex_t *)mutex);
02525       <span class="keywordflow">return</span>;
02526   }
02527 
02528 <span class="preprocessor">#endif </span><span class="comment">/* _WITH_PTHREADS */</span>
02529 
02530   <span class="keywordflow">return</span>;
02531 }
02532 
02533 
02534 <span class="comment">/* end of util.c */</span>
</div></pre><hr size="1"><address style="align: right;"><small>Generated on Thu Sep 16 18:10:47 2004 for libSPF v1.0 by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 ></a> 1.3.8 </small></address>
</body>
</html>
